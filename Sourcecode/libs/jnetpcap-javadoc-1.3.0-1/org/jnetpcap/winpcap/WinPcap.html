<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_07) on Sat Apr 02 12:55:34 EDT 2011 -->
<TITLE>
WinPcap
</TITLE>

<META NAME="date" CONTENT="2011-04-02">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="WinPcap";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/winpcap/WinPcap.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="WinPcap.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.jnetpcap.winpcap</FONT>
<BR>
Class WinPcap</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="../../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">org.jnetpcap.Pcap</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.jnetpcap.winpcap.WinPcap</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>WinPcap</B><DT>extends <A HREF="../../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A></DL>
</PRE>

<P>
<p>
 Class peered with native <code>pcap_t</code> structure providing WinPcap
 specific extensions to libpcap library. To access WinPcap extensions, you
 must use WinPcap class and its methods. <code>WinPcap</code> class extends
 Pcap class so you have all of the typeical <code>Pcap</code> class
 functionality. WinPcap provides many additional methods which are only
 available on platforms what support WinPcap. First you must use static
 <code>WinPcap.isSupported()</code> method call which will return a boolean
 that will indicate if WinPcap extensions are supported on this particular
 platform. If you try and use any method in this class when WinPcap extensions
 are not supported, another words <code>WinPcap.isSupported()</code> returned
 false, every method in this calls will throw unchecked
 <code><A HREF="../../../org/jnetpcap/PcapExtensionNotAvailableException.html" title="class in org.jnetpcap"><CODE>PcapExtensionNotAvailableException</CODE></A></code>. Of course,
 <code>isSupported</code> call itself never throws an exception. So its safe
 to use on any platform.
 
 <pre>
 // Before using any WinPcap code
 if (WinPcap.isSupported() == false) {
        return; // Can't use WinPcap extensions
 }
 </pre>
 
 </p>
 <h1>Using WinPcap class</h1> For the most part, you use <code>WinPcap</code>
 the same way you would use <code>Pcap</code> class. <code>WinPcap</code>
 class provides many different static methods, and the same main three methods
 that <code>Pcap</code> does to open a capture session, plus one extra. They
 are:
 <ul>
 <li>openLive - opens a live capture from network interface
 <li>openOffline - opens a capture file
 <li>openDead - opens a dummy capture for filter compiling
 <li>open - special open command that uses the <em>source string</em> syntax
 to accomplish the same tasks as the three openXXX methods before it.
 </ul>
 There are also several addition methods:
 <ul>
 <li>findAllDevsEx - extended version of <code>Pcap.findAllDevs</code> which
 allows you to not only find network interfaces, but also PCAP files. This can
 be done locally or remotely.
 <li>liveDump - which can dump captured packets to a savefile automatically at
 the kernel level.
 <li>sendQueueTransmit - and related method, which allow raw packets to be
 sent in bulk, efficiently.
 <li>setMinToCopy, setMode and setBuf - allow tweaking of kernel buffers and
 enable/disable statistical captures
 <li>offlineFilter - ability to apply the BPF filter on your own packets
 without a capture
 <li>setSampling - changes the mode of the capture where only samples of a
 capture are retruend. packets
 <li>statEx - extended statistics that include counters on RPCAP remote
 connection
 </ul>
 <h1>Using WinPcap.findAllDevsEx</h1> The new method uses
 <em>source string</em> and WinPcapRmtAuth object and allows remote lookups of
 interfraces and files. A local lookup:
 
 <pre>
 String source = &quot;rpcap://&quot;;
 List&lt;PcapIf&gt; alldevs = new ArrayList&lt;PcapIf&gt;();
 
 int r = WinPcap.findAllDevsEx(source, auth, alldevs, errbuf);
 if (r != Pcap.OK) {
        fail(errbuf.toString());
        return;
 }
 
 System.out.println(&quot;device list is &quot; + alldevs);
 </pre>
 
 Now we have a list of PcapIf objects. You can use
 <code>PcapIf.getName()</code> which contains already properly formatted name
 to be passed to <code>WinPcap.open</code> call. <h1>Using WinPcap.open method
 </h1> Once you have a reference to a WinPcap object, you can then call any of
 its dynamic methods. Here is a straight forward example how to open a capture
 session and then close it:
 
 <pre>
 WinPcap pcap = WinPcap.openLive(device, snaplen, flags, timeout, errbuf);
 // Do something
 pcap.close();
 </pre>
 
 This is identical to <code>Pcap.openLive</code> method with the exception
 that <code>WinPcap</code> object is returned. WinPcap extends Pcap. Here is
 the same example this time using WinPcap's <em>source string</em> code and a
 bogus device name (you will need to substitute your own actual device name):
 
 <pre>
  String source = &quot;rpcap://\\Device\\NPF_{BC81C4FC-242F-4F1C-9DAD-EA9523CC992D}&quot;;
  int snaplen = 64 * 1024;
  int flags = Pcap.MODE_NON_PROMISCUOUS;
  int timeout = 1000;
  WinPcapRmtAuth auth = null;
  StringBuffer errbuf = new StringBuffer();
 
  WinPcap pcap = WinPcap.open(source, snaplen, flags, timeout, auth, errbuf);
  if (pcap == null) {
        System.err.println(errbuf.toString());
        return;
  }
  pcap.close(); }
 </pre>
 
 We use <code>open</code> method which takes a <code>WinPcapRmtAuth</code>
 object. We could set username and password in it, but we chose the 'NULL'
 authentication method. The remote server has to be configured with a '-n'
 command line argument to access 'NULL' authentication.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Mark Bednarczyk, Sly Technologies, Inc.</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap"><CODE>Pcap</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#MODE_CAPT">MODE_CAPT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default capture mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#MODE_MONITOR">MODE_MONITOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;monitor mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#MODE_STAT">MODE_STAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;statistical mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#OPENFLAG_DATATX_UDP">OPENFLAG_DATATX_UDP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines if the data transfer (in case of a remote capture) has to be done
 with UDP protocol and can only be used with <code>WinPcap.open</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#OPENFLAG_MAX_RESPONSIVENESS">OPENFLAG_MAX_RESPONSIVENESS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This flag configures the adapter for maximum responsiveness and can only be
 used with <code>WinPcap.open</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#OPENFLAG_NOCAPTURE_LOCAL">OPENFLAG_NOCAPTURE_LOCAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines if the local adapter will capture its own generated traffic and can
 only be used with <code>WinPcap.open</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#OPENFLAG_NOCAPTURE_RPCAP">OPENFLAG_NOCAPTURE_RPCAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines if the remote probe will capture its own generated traffic and can
 only be used with <code>WinPcap.open</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#SRC_FILE">SRC_FILE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to create a <em>source string</em> using method
 <code>createSrcStr</code>, which will be used to open a local capture file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#SRC_IFLOCAL">SRC_IFLOCAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to create a <em>source string</em> using method
 <code>createSrcStr</code>, which will be used to open a local network
 interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#SRC_IFREMOTE">SRC_IFREMOTE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used to create a <em>source string</em> using method
 <code>createSrcStr</code>,which will be used to open a remote connection
 (could be file, or network interface on remote system).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#TRANSMIT_SYNCH_ASAP">TRANSMIT_SYNCH_ASAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag used with <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)"><CODE>sendQueueTransmit(WinPcapSendQueue, int)</CODE></A>, to tell
 kernel to send packets as fast as possible, without synchronizing with
 packet timestamps found in headers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#TRANSMIT_SYNCH_USE_TIMESTAMP">TRANSMIT_SYNCH_USE_TIMESTAMP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag used with <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)"><CODE>sendQueueTransmit(WinPcapSendQueue, int)</CODE></A>, to tell
 kernel to send packets at the rate that is determined by the timestamp with
 in the sendqueue.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_org.jnetpcap.Pcap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class org.jnetpcap.<A HREF="../../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/jnetpcap/Pcap.html#DEFAULT_PROMISC">DEFAULT_PROMISC</A>, <A HREF="../../../org/jnetpcap/Pcap.html#DEFAULT_SNAPLEN">DEFAULT_SNAPLEN</A>, <A HREF="../../../org/jnetpcap/Pcap.html#DEFAULT_TIMEOUT">DEFAULT_TIMEOUT</A>, <A HREF="../../../org/jnetpcap/Pcap.html#DISPATCH_BUFFER_FULL">DISPATCH_BUFFER_FULL</A>, <A HREF="../../../org/jnetpcap/Pcap.html#JNETPCAP_LIBRARY_NAME">JNETPCAP_LIBRARY_NAME</A>, <A HREF="../../../org/jnetpcap/Pcap.html#LOOP_INFINATE">LOOP_INFINATE</A>, <A HREF="../../../org/jnetpcap/Pcap.html#LOOP_INFINITE">LOOP_INFINITE</A>, <A HREF="../../../org/jnetpcap/Pcap.html#LOOP_INTERRUPTED">LOOP_INTERRUPTED</A>, <A HREF="../../../org/jnetpcap/Pcap.html#MODE_BLOCKING">MODE_BLOCKING</A>, <A HREF="../../../org/jnetpcap/Pcap.html#MODE_NON_BLOCKING">MODE_NON_BLOCKING</A>, <A HREF="../../../org/jnetpcap/Pcap.html#MODE_NON_PROMISCUOUS">MODE_NON_PROMISCUOUS</A>, <A HREF="../../../org/jnetpcap/Pcap.html#MODE_PROMISCUOUS">MODE_PROMISCUOUS</A>, <A HREF="../../../org/jnetpcap/Pcap.html#NEXT_EX_EOF">NEXT_EX_EOF</A>, <A HREF="../../../org/jnetpcap/Pcap.html#NEXT_EX_NOT_OK">NEXT_EX_NOT_OK</A>, <A HREF="../../../org/jnetpcap/Pcap.html#NEXT_EX_OK">NEXT_EX_OK</A>, <A HREF="../../../org/jnetpcap/Pcap.html#NEXT_EX_TIMEDOUT">NEXT_EX_TIMEDOUT</A>, <A HREF="../../../org/jnetpcap/Pcap.html#NOT_OK">NOT_OK</A>, <A HREF="../../../org/jnetpcap/Pcap.html#OK">OK</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#createSrcStr(java.lang.Appendable, int, java.lang.String, java.lang.String, java.lang.String, java.lang.Appendable)">createSrcStr</A></B>(java.lang.Appendable&nbsp;source,
             int&nbsp;type,
             java.lang.String&nbsp;host,
             java.lang.String&nbsp;port,
             java.lang.String&nbsp;name,
             java.lang.Appendable&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accept a set of strings (host name, port, ...), and it returns the complete
 source string according to the new format (e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#createSrcStr(java.lang.StringBuffer, int, java.lang.String, java.lang.String, java.lang.String, java.lang.StringBuffer)">createSrcStr</A></B>(java.lang.StringBuffer&nbsp;source,
             int&nbsp;type,
             java.lang.String&nbsp;host,
             java.lang.String&nbsp;port,
             java.lang.String&nbsp;name,
             java.lang.StringBuffer&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accept a set of strings (host name, port, ...), and it returns the complete
 source string according to the new format (e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#createSrcStr(java.lang.StringBuilder, int, java.lang.String, java.lang.String, java.lang.String, java.lang.StringBuilder)">createSrcStr</A></B>(java.lang.StringBuilder&nbsp;source,
             int&nbsp;type,
             java.lang.String&nbsp;host,
             java.lang.String&nbsp;port,
             java.lang.String&nbsp;name,
             java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accept a set of strings (host name, port, ...), and it returns the complete
 source string according to the new format (e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#findAllDevsEx(java.lang.String, org.jnetpcap.winpcap.WinPcapRmtAuth, java.util.List, java.lang.Appendable)">findAllDevsEx</A></B>(java.lang.String&nbsp;source,
              <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
              java.util.List&lt;<A HREF="../../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
              java.lang.Appendable&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a list of network devices that can be opened with pcap_open().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#findAllDevsEx(java.lang.String, org.jnetpcap.winpcap.WinPcapRmtAuth, java.util.List, java.lang.StringBuffer)">findAllDevsEx</A></B>(java.lang.String&nbsp;source,
              <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
              java.util.List&lt;<A HREF="../../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
              java.lang.StringBuffer&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a list of network devices that can be opened with pcap_open().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#findAllDevsEx(java.lang.String, org.jnetpcap.winpcap.WinPcapRmtAuth, java.util.List, java.lang.StringBuilder)">findAllDevsEx</A></B>(java.lang.String&nbsp;source,
              <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
              java.util.List&lt;<A HREF="../../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
              java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a list of network devices that can be opened with pcap_open().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#isSupported()">isSupported</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if <i>WinPcap</i> extensions are available on this platform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#liveDump(java.lang.String, int, int)">liveDump</A></B>(java.lang.String&nbsp;fname,
         int&nbsp;maxsize,
         int&nbsp;maxpackets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dumps the network traffic from an interface to a file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#liveDumpEnded(int)">liveDumpEnded</A></B>(int&nbsp;sync)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the status of the kernel dump process, i.e.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, int, int, java.nio.ByteBuffer)">offlineFilter</A></B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
              int&nbsp;caplen,
              int&nbsp;len,
              java.nio.ByteBuffer&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if a given filter applies to an offline packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, java.nio.ByteBuffer)">offlineFilter</A></B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
              <A HREF="../../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;header,
              java.nio.ByteBuffer&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if a given filter applies to an offline packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)">offlineFilter</A></B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
              <A HREF="../../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;header,
              <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if a given filter applies to an offline packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapPktHdr, java.nio.ByteBuffer)">offlineFilter</A></B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
              <A HREF="../../../org/jnetpcap/PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</A>&nbsp;header,
              java.nio.ByteBuffer&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>replaced by
             <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><CODE>offlineFilter(PcapBpfProgram, PcapHeader, JBuffer)</CODE></A></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#open(java.lang.String, int, int, int, org.jnetpcap.winpcap.WinPcapRmtAuth, java.lang.Appendable)">open</A></B>(java.lang.String&nbsp;source,
     int&nbsp;snaplen,
     int&nbsp;flags,
     int&nbsp;timeout,
     <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
     java.lang.Appendable&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a generic source in order to capture/send (WinPcap only) traffic.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#open(java.lang.String, int, int, int, org.jnetpcap.winpcap.WinPcapRmtAuth, java.lang.StringBuffer)">open</A></B>(java.lang.String&nbsp;source,
     int&nbsp;snaplen,
     int&nbsp;flags,
     int&nbsp;timeout,
     <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
     java.lang.StringBuffer&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a generic source in order to capture/send (WinPcap only) traffic.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#open(java.lang.String, int, int, int, org.jnetpcap.winpcap.WinPcapRmtAuth, java.lang.StringBuilder)">open</A></B>(java.lang.String&nbsp;source,
     int&nbsp;snaplen,
     int&nbsp;flags,
     int&nbsp;timeout,
     <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
     java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a generic source in order to capture/send (WinPcap only) traffic.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openDead(int, int)">openDead</A></B>(int&nbsp;linktype,
         int&nbsp;snaplen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a pcap_t structure without starting a capture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openLive(java.lang.String, int, int, int, java.lang.Appendable)">openLive</A></B>(java.lang.String&nbsp;device,
         int&nbsp;snaplen,
         int&nbsp;promisc,
         int&nbsp;timeout,
         java.lang.Appendable&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 This method, overrides the generic libpcap based <code>openLive</code>
 method, and allocates a peer pcap object that allows WinPcap extensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuffer)">openLive</A></B>(java.lang.String&nbsp;device,
         int&nbsp;snaplen,
         int&nbsp;promisc,
         int&nbsp;timeout,
         java.lang.StringBuffer&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 This method, overrides the generic libpcap based <code>openLive</code>
 method, and allocates a peer pcap object that allows WinPcap extensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)">openLive</A></B>(java.lang.String&nbsp;device,
         int&nbsp;snaplen,
         int&nbsp;promisc,
         int&nbsp;timeout,
         java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 This method, overrides the generic libpcap based <code>openLive</code>
 method, and allocates a peer pcap object that allows WinPcap extensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openOffline(java.lang.String, java.lang.Appendable)">openOffline</A></B>(java.lang.String&nbsp;fname,
            java.lang.Appendable&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a savefile in the tcpdump/libpcap format to read packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openOffline(java.lang.String, java.lang.StringBuffer)">openOffline</A></B>(java.lang.String&nbsp;fname,
            java.lang.StringBuffer&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a savefile in the tcpdump/libpcap format to read packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openOffline(java.lang.String, java.lang.StringBuilder)">openOffline</A></B>(java.lang.String&nbsp;fname,
            java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a savefile in the tcpdump/libpcap format to read packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcapSendQueue.html" title="class in org.jnetpcap.winpcap">WinPcapSendQueue</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueAlloc(int)">sendQueueAlloc</A></B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate a send queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueDestroy(org.jnetpcap.winpcap.WinPcapSendQueue)">sendQueueDestroy</A></B>(<A HREF="../../../org/jnetpcap/winpcap/WinPcapSendQueue.html" title="class in org.jnetpcap.winpcap">WinPcapSendQueue</A>&nbsp;queue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy a send queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)">sendQueueTransmit</A></B>(<A HREF="../../../org/jnetpcap/winpcap/WinPcapSendQueue.html" title="class in org.jnetpcap.winpcap">WinPcapSendQueue</A>&nbsp;queue,
                  int&nbsp;synch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Send a queue of raw packets to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#setBuff(int)">setBuff</A></B>(int&nbsp;dim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the size of the kernel buffer associated with an adapter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#setMinToCopy(int)">setMinToCopy</A></B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the minumum amount of data received by the kernel in a single call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#setMode(int)">setMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the working mode of the interface p to mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcapSamp.html" title="class in org.jnetpcap.winpcap">WinPcapSamp</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#setSampling()">setSampling</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Define a sampling method for packet capture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcapStat.html" title="class in org.jnetpcap.winpcap">WinPcapStat</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#statsEx()">statsEx</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method extends the <code>Pcap.stats</code> method and allows more
 statistics to be returned.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.jnetpcap.Pcap"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class org.jnetpcap.<A HREF="../../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../org/jnetpcap/Pcap.html#breakloop()">breakloop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#checkIsActive()">checkIsActive</A>, <A HREF="../../../org/jnetpcap/Pcap.html#close()">close</A>, <A HREF="../../../org/jnetpcap/Pcap.html#compile(org.jnetpcap.PcapBpfProgram, java.lang.String, int, int)">compile</A>, <A HREF="../../../org/jnetpcap/Pcap.html#compileNoPcap(int, int, org.jnetpcap.PcapBpfProgram, java.lang.String, int, int)">compileNoPcap</A>, <A HREF="../../../org/jnetpcap/Pcap.html#datalink()">datalink</A>, <A HREF="../../../org/jnetpcap/Pcap.html#datalinkNameToVal(java.lang.String)">datalinkNameToVal</A>, <A HREF="../../../org/jnetpcap/Pcap.html#datalinkValToDescription(int)">datalinkValToDescription</A>, <A HREF="../../../org/jnetpcap/Pcap.html#datalinkValToName(int)">datalinkValToName</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.ByteBufferHandler, T)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, int, org.jnetpcap.packet.JPacketHandler, T)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, int, org.jnetpcap.packet.PcapPacketHandler, T)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.JBufferHandler, T)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.JPacketHandler, T)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.JPacketHandler, T, org.jnetpcap.packet.JScanner)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.PcapDumper)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.PcapHandler, T)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.PcapPacketHandler, T)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.PcapPacketHandler, T, org.jnetpcap.packet.JScanner)">dispatch</A>, <A HREF="../../../org/jnetpcap/Pcap.html#dumpOpen(java.lang.String)">dumpOpen</A>, <A HREF="../../../org/jnetpcap/Pcap.html#finalize()">finalize</A>, <A HREF="../../../org/jnetpcap/Pcap.html#findAllDevs(java.util.List, java.lang.StringBuilder)">findAllDevs</A>, <A HREF="../../../org/jnetpcap/Pcap.html#freeAllDevs(java.util.List, byte[])">freeAllDevs</A>, <A HREF="../../../org/jnetpcap/Pcap.html#freeAllDevs(java.util.List, java.lang.StringBuilder)">freeAllDevs</A>, <A HREF="../../../org/jnetpcap/Pcap.html#freecode(org.jnetpcap.PcapBpfProgram)">freecode</A>, <A HREF="../../../org/jnetpcap/Pcap.html#getErr()">getErr</A>, <A HREF="../../../org/jnetpcap/Pcap.html#getNonBlock(java.lang.StringBuilder)">getNonBlock</A>, <A HREF="../../../org/jnetpcap/Pcap.html#inject(byte[])">inject</A>, <A HREF="../../../org/jnetpcap/Pcap.html#inject(byte[], int, int)">inject</A>, <A HREF="../../../org/jnetpcap/Pcap.html#inject(java.nio.ByteBuffer)">inject</A>, <A HREF="../../../org/jnetpcap/Pcap.html#inject(org.jnetpcap.nio.JBuffer, int, int)">inject</A>, <A HREF="../../../org/jnetpcap/Pcap.html#isInjectSupported()">isInjectSupported</A>, <A HREF="../../../org/jnetpcap/Pcap.html#isSendPacketSupported()">isSendPacketSupported</A>, <A HREF="../../../org/jnetpcap/Pcap.html#isSwapped()">isSwapped</A>, <A HREF="../../../org/jnetpcap/Pcap.html#libVersion()">libVersion</A>, <A HREF="../../../org/jnetpcap/Pcap.html#lookupDev(java.lang.StringBuilder)">lookupDev</A>, <A HREF="../../../org/jnetpcap/Pcap.html#lookupNet(java.lang.String, org.jnetpcap.nio.JNumber, org.jnetpcap.nio.JNumber, java.lang.StringBuilder)">lookupNet</A>, <A HREF="../../../org/jnetpcap/Pcap.html#lookupNet(java.lang.String, org.jnetpcap.PcapInteger, org.jnetpcap.PcapInteger, java.lang.StringBuilder)">lookupNet</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.ByteBufferHandler, T)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, int, org.jnetpcap.packet.JPacketHandler, T)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, int, org.jnetpcap.packet.PcapPacketHandler, T)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.JBufferHandler, T)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.JPacketHandler, T)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.JPacketHandler, T, org.jnetpcap.packet.JScanner)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.PcapDumper)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.PcapHandler, T)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.PcapPacketHandler, T)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.PcapPacketHandler, T, org.jnetpcap.packet.JScanner)">loop</A>, <A HREF="../../../org/jnetpcap/Pcap.html#majorVersion()">majorVersion</A>, <A HREF="../../../org/jnetpcap/Pcap.html#minorVersion()">minorVersion</A>, <A HREF="../../../org/jnetpcap/Pcap.html#next(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)">next</A>, <A HREF="../../../org/jnetpcap/Pcap.html#next(org.jnetpcap.PcapPktHdr)">next</A>, <A HREF="../../../org/jnetpcap/Pcap.html#nextEx(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)">nextEx</A>, <A HREF="../../../org/jnetpcap/Pcap.html#nextEx(org.jnetpcap.packet.PcapPacket)">nextEx</A>, <A HREF="../../../org/jnetpcap/Pcap.html#nextEx(org.jnetpcap.PcapPktHdr, org.jnetpcap.PcapPktBuffer)">nextEx</A>, <A HREF="../../../org/jnetpcap/Pcap.html#sendPacket(byte[])">sendPacket</A>, <A HREF="../../../org/jnetpcap/Pcap.html#sendPacket(byte[], int, int)">sendPacket</A>, <A HREF="../../../org/jnetpcap/Pcap.html#sendPacket(java.nio.ByteBuffer)">sendPacket</A>, <A HREF="../../../org/jnetpcap/Pcap.html#sendPacket(org.jnetpcap.nio.JBuffer)">sendPacket</A>, <A HREF="../../../org/jnetpcap/Pcap.html#setDatalink(int)">setDatalink</A>, <A HREF="../../../org/jnetpcap/Pcap.html#setFilter(org.jnetpcap.PcapBpfProgram)">setFilter</A>, <A HREF="../../../org/jnetpcap/Pcap.html#setNonBlock(int, java.lang.StringBuilder)">setNonBlock</A>, <A HREF="../../../org/jnetpcap/Pcap.html#snapshot()">snapshot</A>, <A HREF="../../../org/jnetpcap/Pcap.html#stats(org.jnetpcap.PcapStat)">stats</A>, <A HREF="../../../org/jnetpcap/Pcap.html#toString()">toString</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MODE_CAPT"><!-- --></A><H3>
MODE_CAPT</H3>
<PRE>
public static final int <B>MODE_CAPT</B></PRE>
<DL>
<DD>default capture mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.MODE_CAPT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MODE_MONITOR"><!-- --></A><H3>
MODE_MONITOR</H3>
<PRE>
public static final int <B>MODE_MONITOR</B></PRE>
<DL>
<DD>monitor mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.MODE_MONITOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MODE_STAT"><!-- --></A><H3>
MODE_STAT</H3>
<PRE>
public static final int <B>MODE_STAT</B></PRE>
<DL>
<DD>statistical mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.MODE_STAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OPENFLAG_DATATX_UDP"><!-- --></A><H3>
OPENFLAG_DATATX_UDP</H3>
<PRE>
public static final int <B>OPENFLAG_DATATX_UDP</B></PRE>
<DL>
<DD>Defines if the data transfer (in case of a remote capture) has to be done
 with UDP protocol and can only be used with <code>WinPcap.open</code>. If
 it is '1' if you want a UDP data connection, '0' if you want a TCP data
 connection; control connection is always TCP-based. A UDP connection is
 much lighter, but it does not guarantee that all the captured packets
 arrive to the client workstation. Moreover, it could be harmful in case of
 network congestion. This flag is meaningless if the source is not a remote
 interface. In that case, it is simply ignored.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.OPENFLAG_DATATX_UDP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OPENFLAG_MAX_RESPONSIVENESS"><!-- --></A><H3>
OPENFLAG_MAX_RESPONSIVENESS</H3>
<PRE>
public static final int <B>OPENFLAG_MAX_RESPONSIVENESS</B></PRE>
<DL>
<DD>This flag configures the adapter for maximum responsiveness and can only be
 used with <code>WinPcap.open</code>. In presence of a large value for
 nbytes, WinPcap waits for the arrival of several packets before copying the
 data to the user. This guarantees a low number of system calls, i.e. lower
 processor usage, i.e. better performance, which is good for applications
 like sniffers. If the user sets the PCAP_OPENFLAG_MAX_RESPONSIVENESS flag,
 the capture driver will copy the packets as soon as the application is
 ready to receive them. This is suggested for real time applications (like,
 for example, a bridge) that need the best responsiveness.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.OPENFLAG_MAX_RESPONSIVENESS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OPENFLAG_NOCAPTURE_LOCAL"><!-- --></A><H3>
OPENFLAG_NOCAPTURE_LOCAL</H3>
<PRE>
public static final int <B>OPENFLAG_NOCAPTURE_LOCAL</B></PRE>
<DL>
<DD>Defines if the local adapter will capture its own generated traffic and can
 only be used with <code>WinPcap.open</code>. This flag tells the underlying
 capture driver to drop the packets that were sent by itself. This is
 usefult when building applications like bridges, that should ignore the
 traffic they just sent.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.OPENFLAG_NOCAPTURE_LOCAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OPENFLAG_NOCAPTURE_RPCAP"><!-- --></A><H3>
OPENFLAG_NOCAPTURE_RPCAP</H3>
<PRE>
public static final int <B>OPENFLAG_NOCAPTURE_RPCAP</B></PRE>
<DL>
<DD>Defines if the remote probe will capture its own generated traffic and can
 only be used with <code>WinPcap.open</code>. In case the remote probe uses
 the same interface to capture traffic and to send data back to the caller,
 the captured traffic includes the RPCAP traffic as well. If this flag is
 turned on, the RPCAP traffic is excluded from the capture, so that the
 trace returned back to the collector is does not include this traffic.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.OPENFLAG_NOCAPTURE_RPCAP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SRC_FILE"><!-- --></A><H3>
SRC_FILE</H3>
<PRE>
public static final int <B>SRC_FILE</B></PRE>
<DL>
<DD>Used to create a <em>source string</em> using method
 <code>createSrcStr</code>, which will be used to open a local capture file.
 Used with <code>createSrcStr</code> for its type field. Used with
 <code>createSrcStr</code> for its type field.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.SRC_FILE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SRC_IFLOCAL"><!-- --></A><H3>
SRC_IFLOCAL</H3>
<PRE>
public static final int <B>SRC_IFLOCAL</B></PRE>
<DL>
<DD>Used to create a <em>source string</em> using method
 <code>createSrcStr</code>, which will be used to open a local network
 interface. Used with <code>createSrcStr</code> for its type field.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.SRC_IFLOCAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SRC_IFREMOTE"><!-- --></A><H3>
SRC_IFREMOTE</H3>
<PRE>
public static final int <B>SRC_IFREMOTE</B></PRE>
<DL>
<DD>Used to create a <em>source string</em> using method
 <code>createSrcStr</code>,which will be used to open a remote connection
 (could be file, or network interface on remote system). Used with
 <code>createSrcStr</code> for its type field.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.SRC_IFREMOTE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSMIT_SYNCH_ASAP"><!-- --></A><H3>
TRANSMIT_SYNCH_ASAP</H3>
<PRE>
public static final int <B>TRANSMIT_SYNCH_ASAP</B></PRE>
<DL>
<DD>Flag used with <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)"><CODE>sendQueueTransmit(WinPcapSendQueue, int)</CODE></A>, to tell
 kernel to send packets as fast as possible, without synchronizing with
 packet timestamps found in headers.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.TRANSMIT_SYNCH_ASAP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSMIT_SYNCH_USE_TIMESTAMP"><!-- --></A><H3>
TRANSMIT_SYNCH_USE_TIMESTAMP</H3>
<PRE>
public static final int <B>TRANSMIT_SYNCH_USE_TIMESTAMP</B></PRE>
<DL>
<DD>Flag used with <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)"><CODE>sendQueueTransmit(WinPcapSendQueue, int)</CODE></A>, to tell
 kernel to send packets at the rate that is determined by the timestamp with
 in the sendqueue. The transmittion is synchronized with timestamps.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.winpcap.WinPcap.TRANSMIT_SYNCH_USE_TIMESTAMP">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="createSrcStr(java.lang.Appendable, int, java.lang.String, java.lang.String, java.lang.String, java.lang.Appendable)"><!-- --></A><H3>
createSrcStr</H3>
<PRE>
public static int <B>createSrcStr</B>(java.lang.Appendable&nbsp;source,
                               int&nbsp;type,
                               java.lang.String&nbsp;host,
                               java.lang.String&nbsp;port,
                               java.lang.String&nbsp;name,
                               java.lang.Appendable&nbsp;errbuf)
                        throws java.io.IOException</PRE>
<DL>
<DD>Accept a set of strings (host name, port, ...), and it returns the complete
 source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0').
 This function is provided in order to help the user creating the source
 string according to the new format. An unique source string is used in
 order to make easy for old applications to use the remote facilities. Think
 about tcpdump, for example, which has only one way to specify the interface
 on which the capture has to be started. However, GUI-based programs can
 find more useful to specify hostname, port and interface name separately.
 In that case, they can use this function to create the source string before
 passing it to the pcap_open() function.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - will contain the complete source string wen the function returns<DD><CODE>type</CODE> - its value tells the type of the source we want to created<DD><CODE>host</CODE> - an user-allocated buffer that keeps the host (e.g. "foo.bar.com")
          we want to connect to. It can be NULL in case we want to open an
          interface on a local host<DD><CODE>port</CODE> - an user-allocated buffer that keeps the network port (e.g. "2002")
          we want to use for the RPCAP protocol. It can be NULL in case we
          want to open an interface on a local host.<DD><CODE>name</CODE> - an user-allocated buffer that keeps the interface name we want to
          use (e.g. "eth0"). It can be NULL in case the return string (i.e.
          'source') has to be used with the pcap_findalldevs_ex(), which
          does not require the interface name.<DD><CODE>errbuf</CODE> - buffer that will contain the error message (in case there is one).
<DT><B>Returns:</B><DD>'0' if everything is fine, '-1' if some errors occurred. The string
         containing the complete source is returned in the 'source'
         variable.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - Signals that an I/O exception has occurred.<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createSrcStr(java.lang.StringBuffer, int, java.lang.String, java.lang.String, java.lang.String, java.lang.StringBuffer)"><!-- --></A><H3>
createSrcStr</H3>
<PRE>
public static int <B>createSrcStr</B>(java.lang.StringBuffer&nbsp;source,
                               int&nbsp;type,
                               java.lang.String&nbsp;host,
                               java.lang.String&nbsp;port,
                               java.lang.String&nbsp;name,
                               java.lang.StringBuffer&nbsp;errbuf)</PRE>
<DL>
<DD>Accept a set of strings (host name, port, ...), and it returns the complete
 source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0').
 This function is provided in order to help the user creating the source
 string according to the new format. An unique source string is used in
 order to make easy for old applications to use the remote facilities. Think
 about tcpdump, for example, which has only one way to specify the interface
 on which the capture has to be started. However, GUI-based programs can
 find more useful to specify hostname, port and interface name separately.
 In that case, they can use this function to create the source string before
 passing it to the pcap_open() function.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - will contain the complete source string wen the function returns<DD><CODE>type</CODE> - its value tells the type of the source we want to created<DD><CODE>host</CODE> - an user-allocated buffer that keeps the host (e.g. "foo.bar.com")
          we want to connect to. It can be NULL in case we want to open an
          interface on a local host<DD><CODE>port</CODE> - an user-allocated buffer that keeps the network port (e.g. "2002")
          we want to use for the RPCAP protocol. It can be NULL in case we
          want to open an interface on a local host.<DD><CODE>name</CODE> - an user-allocated buffer that keeps the interface name we want to
          use (e.g. "eth0"). It can be NULL in case the return string (i.e.
          'source') has to be used with the pcap_findalldevs_ex(), which
          does not require the interface name.<DD><CODE>errbuf</CODE> - buffer that will contain the error message (in case there is one).
<DT><B>Returns:</B><DD>'0' if everything is fine, '-1' if some errors occurred. The string
         containing the complete source is returned in the 'source'
         variable.<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createSrcStr(java.lang.StringBuilder, int, java.lang.String, java.lang.String, java.lang.String, java.lang.StringBuilder)"><!-- --></A><H3>
createSrcStr</H3>
<PRE>
public static int <B>createSrcStr</B>(java.lang.StringBuilder&nbsp;source,
                               int&nbsp;type,
                               java.lang.String&nbsp;host,
                               java.lang.String&nbsp;port,
                               java.lang.String&nbsp;name,
                               java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>Accept a set of strings (host name, port, ...), and it returns the complete
 source string according to the new format (e.g. 'rpcap://1.2.3.4/eth0').
 This function is provided in order to help the user creating the source
 string according to the new format. An unique source string is used in
 order to make easy for old applications to use the remote facilities. Think
 about tcpdump, for example, which has only one way to specify the interface
 on which the capture has to be started. However, GUI-based programs can
 find more useful to specify hostname, port and interface name separately.
 In that case, they can use this function to create the source string before
 passing it to the pcap_open() function.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - will contain the complete source string wen the function returns<DD><CODE>type</CODE> - its value tells the type of the source we want to created<DD><CODE>host</CODE> - an user-allocated buffer that keeps the host (e.g. "foo.bar.com")
          we want to connect to. It can be NULL in case we want to open an
          interface on a local host<DD><CODE>port</CODE> - an user-allocated buffer that keeps the network port (e.g. "2002")
          we want to use for the RPCAP protocol. It can be NULL in case we
          want to open an interface on a local host.<DD><CODE>name</CODE> - an user-allocated buffer that keeps the interface name we want to
          use (e.g. "eth0"). It can be NULL in case the return string (i.e.
          'source') has to be used with the pcap_findalldevs_ex(), which
          does not require the interface name.<DD><CODE>errbuf</CODE> - buffer that will contain the error message (in case there is one).
<DT><B>Returns:</B><DD>'0' if everything is fine, '-1' if some errors occurred. The string
         containing the complete source is returned in the 'source'
         variable.</DL>
</DD>
</DL>
<HR>

<A NAME="findAllDevsEx(java.lang.String, org.jnetpcap.winpcap.WinPcapRmtAuth, java.util.List, java.lang.Appendable)"><!-- --></A><H3>
findAllDevsEx</H3>
<PRE>
public static int <B>findAllDevsEx</B>(java.lang.String&nbsp;source,
                                <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
                                java.util.List&lt;<A HREF="../../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
                                java.lang.Appendable&nbsp;errbuf)
                         throws java.io.IOException</PRE>
<DL>
<DD>Create a list of network devices that can be opened with pcap_open(). </p>
 <p>
 This function is a superset of the old 'pcap_findalldevs()', which is
 obsolete, and which allows listing only the devices present on the local
 machine. Vice versa, pcap_findalldevs_ex() allows listing the devices
 present on a remote machine as well. Additionally, it can list all the pcap
 files available into a given folder. Moreover, pcap_findalldevs_ex() is
 platform independent, since it relies on the standard pcap_findalldevs() to
 get addresses on the local machine.
 </p>
 <p>
 In case the function has to list the interfaces on a remote machine, it
 opens a new control connection toward that machine, it retrieves the
 interfaces, and it drops the connection. However, if this function detects
 that the remote machine is in 'active' mode, the connection is not dropped
 and the existing socket is used.
 </p>
 <p>
 The 'source' is a parameter that tells the function where the lookup has to
 be done and it uses the same syntax of the pcap_open().
 </p>
 <p>
 Differently from the pcap_findalldevs(), the interface names (pointed by
 the alldevs->name and the other ones in the linked list) are already ready
 to be used in the pcap_open() call. Vice versa, the output that comes from
 pcap_findalldevs() must be formatted with the new pcap_createsrcstr()
 before passing the source identifier to the pcap_open().
 </p>
 <p>
 The error message is returned in the 'errbuf' variable. An error could be
 due to several reasons:
 <ul>
 <li>libpcap/WinPcap was not installed on the local/remote host
 <li>the user does not have enough privileges to list the devices / files
 <li>a network problem
 <li>the RPCAP version negotiation failed
 <li>other errors (not enough memory and others).
 </ul>
 </p>
 <p>
 Warning:<br>
 There may be network devices that cannot be opened with pcap_open() by the
 process calling pcap_findalldevs(), because, for example, that process
 might not have sufficient privileges to open them for capturing; if so,
 those devices will not appear on the list. The interface list must be
 deallocated manually by using the pcap_freealldevs().
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a char* buffer that keeps the 'source localtion', according to the
          new WinPcap syntax. This source will be examined looking for
          adapters (local or remote) (e.g. source can be 'rpcap://' for
          local adapters or 'rpcap://host:port' for adapters on a remote
          host) or pcap files (e.g. source can be 'file://c:/myfolder/').
          The strings that must be prepended to the 'source' in order to
          define if we want local/remote adapters or files is defined in the
          new Source Specification Syntax<DD><CODE>auth</CODE> - a pointer to a pcap_rmtauth structure. This pointer keeps the
          information required to authenticate the RPCAP connection to the
          remote host. This parameter is not meaningful in case of a query
          to the local host: in that case it can be NULL.<DD><CODE>alldevs</CODE> - a list of all the network interfaces<DD><CODE>errbuf</CODE> - error message (in case there is one)
<DT><B>Returns:</B><DD>'0' if everything is fine, '-1' if some errors occurred; this
         function returns '-1' also in case the system does not have any
         interface to list
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - Signals that an I/O exception has occurred.<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="findAllDevsEx(java.lang.String, org.jnetpcap.winpcap.WinPcapRmtAuth, java.util.List, java.lang.StringBuffer)"><!-- --></A><H3>
findAllDevsEx</H3>
<PRE>
public static int <B>findAllDevsEx</B>(java.lang.String&nbsp;source,
                                <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
                                java.util.List&lt;<A HREF="../../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
                                java.lang.StringBuffer&nbsp;errbuf)</PRE>
<DL>
<DD>Create a list of network devices that can be opened with pcap_open(). </p>
 <p>
 This function is a superset of the old 'pcap_findalldevs()', which is
 obsolete, and which allows listing only the devices present on the local
 machine. Vice versa, pcap_findalldevs_ex() allows listing the devices
 present on a remote machine as well. Additionally, it can list all the pcap
 files available into a given folder. Moreover, pcap_findalldevs_ex() is
 platform independent, since it relies on the standard pcap_findalldevs() to
 get addresses on the local machine.
 </p>
 <p>
 In case the function has to list the interfaces on a remote machine, it
 opens a new control connection toward that machine, it retrieves the
 interfaces, and it drops the connection. However, if this function detects
 that the remote machine is in 'active' mode, the connection is not dropped
 and the existing socket is used.
 </p>
 <p>
 The 'source' is a parameter that tells the function where the lookup has to
 be done and it uses the same syntax of the pcap_open().
 </p>
 <p>
 Differently from the pcap_findalldevs(), the interface names (pointed by
 the alldevs->name and the other ones in the linked list) are already ready
 to be used in the pcap_open() call. Vice versa, the output that comes from
 pcap_findalldevs() must be formatted with the new pcap_createsrcstr()
 before passing the source identifier to the pcap_open().
 </p>
 <p>
 The error message is returned in the 'errbuf' variable. An error could be
 due to several reasons:
 <ul>
 <li>libpcap/WinPcap was not installed on the local/remote host
 <li>the user does not have enough privileges to list the devices / files
 <li>a network problem
 <li>the RPCAP version negotiation failed
 <li>other errors (not enough memory and others).
 </ul>
 </p>
 <p>
 Warning:<br>
 There may be network devices that cannot be opened with pcap_open() by the
 process calling pcap_findalldevs(), because, for example, that process
 might not have sufficient privileges to open them for capturing; if so,
 those devices will not appear on the list. The interface list must be
 deallocated manually by using the pcap_freealldevs().
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a char* buffer that keeps the 'source localtion', according to the
          new WinPcap syntax. This source will be examined looking for
          adapters (local or remote) (e.g. source can be 'rpcap://' for
          local adapters or 'rpcap://host:port' for adapters on a remote
          host) or pcap files (e.g. source can be 'file://c:/myfolder/').
          The strings that must be prepended to the 'source' in order to
          define if we want local/remote adapters or files is defined in the
          new Source Specification Syntax<DD><CODE>auth</CODE> - a pointer to a pcap_rmtauth structure. This pointer keeps the
          information required to authenticate the RPCAP connection to the
          remote host. This parameter is not meaningful in case of a query
          to the local host: in that case it can be NULL.<DD><CODE>alldevs</CODE> - a list of all the network interfaces<DD><CODE>errbuf</CODE> - error message (in case there is one)
<DT><B>Returns:</B><DD>'0' if everything is fine, '-1' if some errors occurred; this
         function returns '-1' also in case the system does not have any
         interface to list<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="findAllDevsEx(java.lang.String, org.jnetpcap.winpcap.WinPcapRmtAuth, java.util.List, java.lang.StringBuilder)"><!-- --></A><H3>
findAllDevsEx</H3>
<PRE>
public static int <B>findAllDevsEx</B>(java.lang.String&nbsp;source,
                                <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
                                java.util.List&lt;<A HREF="../../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
                                java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>Create a list of network devices that can be opened with pcap_open(). </p>
 <p>
 This function is a superset of the old 'pcap_findalldevs()', which is
 obsolete, and which allows listing only the devices present on the local
 machine. Vice versa, pcap_findalldevs_ex() allows listing the devices
 present on a remote machine as well. Additionally, it can list all the pcap
 files available into a given folder. Moreover, pcap_findalldevs_ex() is
 platform independent, since it relies on the standard pcap_findalldevs() to
 get addresses on the local machine.
 </p>
 <p>
 In case the function has to list the interfaces on a remote machine, it
 opens a new control connection toward that machine, it retrieves the
 interfaces, and it drops the connection. However, if this function detects
 that the remote machine is in 'active' mode, the connection is not dropped
 and the existing socket is used.
 </p>
 <p>
 The 'source' is a parameter that tells the function where the lookup has to
 be done and it uses the same syntax of the pcap_open().
 </p>
 <p>
 Differently from the pcap_findalldevs(), the interface names (pointed by
 the alldevs->name and the other ones in the linked list) are already ready
 to be used in the pcap_open() call. Vice versa, the output that comes from
 pcap_findalldevs() must be formatted with the new pcap_createsrcstr()
 before passing the source identifier to the pcap_open().
 </p>
 <p>
 The error message is returned in the 'errbuf' variable. An error could be
 due to several reasons:
 <ul>
 <li>libpcap/WinPcap was not installed on the local/remote host
 <li>the user does not have enough privileges to list the devices / files
 <li>a network problem
 <li>the RPCAP version negotiation failed
 <li>other errors (not enough memory and others).
 </ul>
 </p>
 <p>
 Warning:<br>
 There may be network devices that cannot be opened with pcap_open() by the
 process calling pcap_findalldevs(), because, for example, that process
 might not have sufficient privileges to open them for capturing; if so,
 those devices will not appear on the list. The interface list must be
 deallocated manually by using the pcap_freealldevs().
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - a char* buffer that keeps the 'source localtion', according to the
          new WinPcap syntax. This source will be examined looking for
          adapters (local or remote) (e.g. source can be 'rpcap://' for
          local adapters or 'rpcap://host:port' for adapters on a remote
          host) or pcap files (e.g. source can be 'file://c:/myfolder/').
          The strings that must be prepended to the 'source' in order to
          define if we want local/remote adapters or files is defined in the
          new Source Specification Syntax<DD><CODE>auth</CODE> - a pointer to a pcap_rmtauth structure. This pointer keeps the
          information required to authenticate the RPCAP connection to the
          remote host. This parameter is not meaningful in case of a query
          to the local host: in that case it can be NULL.<DD><CODE>alldevs</CODE> - a list of all the network interfaces<DD><CODE>errbuf</CODE> - error message (in case there is one)
<DT><B>Returns:</B><DD>'0' if everything is fine, '-1' if some errors occurred; this
         function returns '-1' also in case the system does not have any
         interface to list</DL>
</DD>
</DL>
<HR>

<A NAME="isSupported()"><!-- --></A><H3>
isSupported</H3>
<PRE>
public static boolean <B>isSupported</B>()</PRE>
<DL>
<DD>Checks if <i>WinPcap</i> extensions are available on this platform. WinPcap
 extensions are found in <i>org.jnetpcap.winpcap</i> package.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> means <i>WinPcap</i> extensions are available and
         loaded, otherwise <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="offlineFilter(org.jnetpcap.PcapBpfProgram, int, int, java.nio.ByteBuffer)"><!-- --></A><H3>
offlineFilter</H3>
<PRE>
public static int <B>offlineFilter</B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
                                int&nbsp;caplen,
                                int&nbsp;len,
                                java.nio.ByteBuffer&nbsp;buf)</PRE>
<DL>
<DD>Returns if a given filter applies to an offline packet. This function is
 used to apply a filter to a packet that is currently in memory. This
 process does not need to open an adapter; we need just to create the proper
 filter (by settings parameters like the snapshot length, or the link-layer
 type) by means of the pcap_compile_nopcap(). The current API of libpcap
 does not allow to receive a packet and to filter the packet after it has
 been received. However, this can be useful in case you want to filter
 packets in the application, instead of into the receiving process. This
 function allows you to do the job.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - bpf filter<DD><CODE>caplen</CODE> - length of the captured packet<DD><CODE>len</CODE> - length of the packet on the wire<DD><CODE>buf</CODE> - buffer containing packet data
<DT><B>Returns:</B><DD>snaplen of the packet or 0 if packet should be rejected</DL>
</DD>
</DL>
<HR>

<A NAME="offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, java.nio.ByteBuffer)"><!-- --></A><H3>
offlineFilter</H3>
<PRE>
public static int <B>offlineFilter</B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
                                <A HREF="../../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;header,
                                java.nio.ByteBuffer&nbsp;buffer)</PRE>
<DL>
<DD>Returns if a given filter applies to an offline packet. This function is
 used to apply a filter to a packet that is currently in memory. This
 process does not need to open an adapter; we need just to create the proper
 filter (by settings parameters like the snapshot length, or the link-layer
 type) by means of the pcap_compile_nopcap(). The current API of libpcap
 does not allow to receive a packet and to filter the packet after it has
 been received. However, this can be useful in case you want to filter
 packets in the application, instead of into the receiving process. This
 function allows you to do the job.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - bpf filter<DD><CODE>header</CODE> - packets header<DD><CODE>buffer</CODE> - buffer containing packet data
<DT><B>Returns:</B><DD>snaplen of the packet or 0 if packet should be rejected<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><!-- --></A><H3>
offlineFilter</H3>
<PRE>
public static int <B>offlineFilter</B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
                                <A HREF="../../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;header,
                                <A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD>Returns if a given filter applies to an offline packet. This function is
 used to apply a filter to a packet that is currently in memory. This
 process does not need to open an adapter; we need just to create the proper
 filter (by settings parameters like the snapshot length, or the link-layer
 type) by means of the pcap_compile_nopcap(). The current API of libpcap
 does not allow to receive a packet and to filter the packet after it has
 been received. However, this can be useful in case you want to filter
 packets in the application, instead of into the receiving process. This
 function allows you to do the job.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - bpf filter<DD><CODE>header</CODE> - packets header<DD><CODE>buffer</CODE> - buffer containing packet data
<DT><B>Returns:</B><DD>snaplen of the packet or 0 if packet should be rejected<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapPktHdr, java.nio.ByteBuffer)"><!-- --></A><H3>
offlineFilter</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static int <B>offlineFilter</B>(<A HREF="../../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
                                           <A HREF="../../../org/jnetpcap/PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</A>&nbsp;header,
                                           java.nio.ByteBuffer&nbsp;buf)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>replaced by
             <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><CODE>offlineFilter(PcapBpfProgram, PcapHeader, JBuffer)</CODE></A></I>
<P>
<DD>Returns if a given filter applies to an offline packet. This function is
 used to apply a filter to a packet that is currently in memory. This
 process does not need to open an adapter; we need just to create the proper
 filter (by settings parameters like the snapshot length, or the link-layer
 type) by means of the pcap_compile_nopcap(). The current API of libpcap
 does not allow to receive a packet and to filter the packet after it has
 been received. However, this can be useful in case you want to filter
 packets in the application, instead of into the receiving process. This
 function allows you to do the job.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - bpf filter<DD><CODE>header</CODE> - packets header<DD><CODE>buf</CODE> - buffer containing packet data
<DT><B>Returns:</B><DD>snaplen of the packet or 0 if packet should be rejected<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, java.nio.ByteBuffer)"><CODE>offlineFilter(PcapBpfProgram, PcapHeader, ByteBuffer)</CODE></A>, 
<A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#offlineFilter(org.jnetpcap.PcapBpfProgram, org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><CODE>offlineFilter(PcapBpfProgram, PcapHeader, JBuffer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="open(java.lang.String, int, int, int, org.jnetpcap.winpcap.WinPcapRmtAuth, java.lang.Appendable)"><!-- --></A><H3>
open</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>open</B>(java.lang.String&nbsp;source,
                           int&nbsp;snaplen,
                           int&nbsp;flags,
                           int&nbsp;timeout,
                           <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
                           java.lang.Appendable&nbsp;errbuf)
                    throws java.io.IOException</PRE>
<DL>
<DD>Open a generic source in order to capture/send (WinPcap only) traffic. The
 <code>open</code> replaces all the <code>openXxx()</code> methods with a
 single call. This method hides the differences between the different
 <code>openXxx()</code> methods so that the programmer does not have to
 manage different opening function. In this way, the 'true' open method is
 decided according to the source type, which is included into the source
 string (in the form of source prefix). This function can rely on the
 <code>createSrcStr</code> to create the string that keeps the capture
 device according to the new syntax, and the <code>parseSrcStr</code> for
 the other way round.
 <p>
 <b>Warning:</b> The source cannot be larger than PCAP_BUF_SIZE. The
 following formats are not allowed as 'source' strings:
 <ul>
 <li>rpcap:// [to open the first local adapter]
 <li>rpcap://hostname/ [to open the first remote adapter]
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - The source name has to include the format prefix according to the
          new Source Specification Syntax and it cannot be NULL. <br>
          On on Linux systems with 2.2 or later kernels, a device argument
          of "any" (i.e. rpcap://any) can be used to capture packets from
          all interfaces. In order to makes the source syntax easier, please
          remember that:
          <ul>
          <li>the adapters returned by the pcap_findalldevs_ex() can be used
          immediately by the pcap_open() <li> in case the user wants to pass
          its own source string to the pcap_open(), the pcap_createsrcstr()
          helps in creating the correct source identifier.
          </ul><DD><CODE>snaplen</CODE> - length of the packet that has to be retained. For each packet
          received by the filter, only the first 'snaplen' bytes are stored
          in the buffer and passed to the user application. For instance,
          snaplen equal to 100 means that only the first 100 bytes of each
          packet are stored.<DD><CODE>flags</CODE> - keeps several flags that can be needed for capturing packet<DD><CODE>timeout</CODE> - read timeout in milliseconds. The read timeout is used to arrange
          that the read not necessarily return immediately when a packet is
          seen, but that it waits for some amount of time to allow more
          packets to arrive and to read multiple packets from the OS kernel
          in one operation. Not all platforms support a read timeout; on
          platforms that don't, the read timeout is ignored.<DD><CODE>auth</CODE> - a pointer to a 'struct pcap_rmtauth' that keeps the information
          required to authenticate the user on a remote machine. In case
          this is not a remote capture, this pointer can be set to NULL.<DD><CODE>errbuf</CODE> - a pointer to a user-allocated buffer which will contain the error
          in case this function fails. The pcap_open() and findalldevs() are
          the only two functions which have this parameter, since they do
          not have (yet) a pointer to a pcap_t structure, which reserves
          space for the error string. Since these functions do not have
          (yet) a pcap_t pointer (the pcap_t pointer is NULL in case of
          errors), they need an explicit 'errbuf' variable. 'errbuf' may
          also be set to warning text when pcap_open_live() succeds; to
          detect this case the caller should store a zero-length string in
          'errbuf' before calling pcap_open_live() and display the warning
          to the user if 'errbuf' is no longer a zero-length string.
<DT><B>Returns:</B><DD>in case of problems, it returns null and the 'errbuf' variable
         keeps the error message.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - Signals that an I/O exception has occurred.<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="open(java.lang.String, int, int, int, org.jnetpcap.winpcap.WinPcapRmtAuth, java.lang.StringBuffer)"><!-- --></A><H3>
open</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>open</B>(java.lang.String&nbsp;source,
                           int&nbsp;snaplen,
                           int&nbsp;flags,
                           int&nbsp;timeout,
                           <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
                           java.lang.StringBuffer&nbsp;errbuf)</PRE>
<DL>
<DD>Open a generic source in order to capture/send (WinPcap only) traffic. The
 <code>open</code> replaces all the <code>openXxx()</code> methods with a
 single call. This method hides the differences between the different
 <code>openXxx()</code> methods so that the programmer does not have to
 manage different opening function. In this way, the 'true' open method is
 decided according to the source type, which is included into the source
 string (in the form of source prefix). This function can rely on the
 <code>createSrcStr</code> to create the string that keeps the capture
 device according to the new syntax, and the <code>parseSrcStr</code> for
 the other way round.
 <p>
 <b>Warning:</b> The source cannot be larger than PCAP_BUF_SIZE. The
 following formats are not allowed as 'source' strings:
 <ul>
 <li>rpcap:// [to open the first local adapter]
 <li>rpcap://hostname/ [to open the first remote adapter]
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - The source name has to include the format prefix according to the
          new Source Specification Syntax and it cannot be NULL. <br>
          On on Linux systems with 2.2 or later kernels, a device argument
          of "any" (i.e. rpcap://any) can be used to capture packets from
          all interfaces. In order to makes the source syntax easier, please
          remember that:
          <ul>
          <li>the adapters returned by the pcap_findalldevs_ex() can be used
          immediately by the pcap_open() <li> in case the user wants to pass
          its own source string to the pcap_open(), the pcap_createsrcstr()
          helps in creating the correct source identifier.
          </ul><DD><CODE>snaplen</CODE> - length of the packet that has to be retained. For each packet
          received by the filter, only the first 'snaplen' bytes are stored
          in the buffer and passed to the user application. For instance,
          snaplen equal to 100 means that only the first 100 bytes of each
          packet are stored.<DD><CODE>flags</CODE> - keeps several flags that can be needed for capturing packet<DD><CODE>timeout</CODE> - read timeout in milliseconds. The read timeout is used to arrange
          that the read not necessarily return immediately when a packet is
          seen, but that it waits for some amount of time to allow more
          packets to arrive and to read multiple packets from the OS kernel
          in one operation. Not all platforms support a read timeout; on
          platforms that don't, the read timeout is ignored.<DD><CODE>auth</CODE> - a pointer to a 'struct pcap_rmtauth' that keeps the information
          required to authenticate the user on a remote machine. In case
          this is not a remote capture, this pointer can be set to NULL.<DD><CODE>errbuf</CODE> - a pointer to a user-allocated buffer which will contain the error
          in case this function fails. The pcap_open() and findalldevs() are
          the only two functions which have this parameter, since they do
          not have (yet) a pointer to a pcap_t structure, which reserves
          space for the error string. Since these functions do not have
          (yet) a pcap_t pointer (the pcap_t pointer is NULL in case of
          errors), they need an explicit 'errbuf' variable. 'errbuf' may
          also be set to warning text when pcap_open_live() succeds; to
          detect this case the caller should store a zero-length string in
          'errbuf' before calling pcap_open_live() and display the warning
          to the user if 'errbuf' is no longer a zero-length string.
<DT><B>Returns:</B><DD>in case of problems, it returns null and the 'errbuf' variable
         keeps the error message.<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="open(java.lang.String, int, int, int, org.jnetpcap.winpcap.WinPcapRmtAuth, java.lang.StringBuilder)"><!-- --></A><H3>
open</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>open</B>(java.lang.String&nbsp;source,
                           int&nbsp;snaplen,
                           int&nbsp;flags,
                           int&nbsp;timeout,
                           <A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap">WinPcapRmtAuth</A>&nbsp;auth,
                           java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>Open a generic source in order to capture/send (WinPcap only) traffic. The
 <code>open</code> replaces all the <code>openXxx()</code> methods with a
 single call. This method hides the differences between the different
 <code>openXxx()</code> methods so that the programmer does not have to
 manage different opening function. In this way, the 'true' open method is
 decided according to the source type, which is included into the source
 string (in the form of source prefix). This function can rely on the
 <code>createSrcStr</code> to create the string that keeps the capture
 device according to the new syntax, and the <code>parseSrcStr</code> for
 the other way round.
 <p>
 <b>Warning:</b> The source cannot be larger than PCAP_BUF_SIZE. The
 following formats are not allowed as 'source' strings:
 <ul>
 <li>rpcap:// [to open the first local adapter]
 <li>rpcap://hostname/ [to open the first remote adapter]
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - The source name has to include the format prefix according to the
          new Source Specification Syntax and it cannot be NULL. <br>
          On on Linux systems with 2.2 or later kernels, a device argument
          of "any" (i.e. rpcap://any) can be used to capture packets from
          all interfaces. In order to makes the source syntax easier, please
          remember that:
          <ul>
          <li>the adapters returned by the pcap_findalldevs_ex() can be used
          immediately by the pcap_open() <li> in case the user wants to pass
          its own source string to the pcap_open(), the pcap_createsrcstr()
          helps in creating the correct source identifier.
          </ul><DD><CODE>snaplen</CODE> - length of the packet that has to be retained. For each packet
          received by the filter, only the first 'snaplen' bytes are stored
          in the buffer and passed to the user application. For instance,
          snaplen equal to 100 means that only the first 100 bytes of each
          packet are stored.<DD><CODE>flags</CODE> - keeps several flags that can be needed for capturing packet<DD><CODE>timeout</CODE> - read timeout in milliseconds. The read timeout is used to arrange
          that the read not necessarily return immediately when a packet is
          seen, but that it waits for some amount of time to allow more
          packets to arrive and to read multiple packets from the OS kernel
          in one operation. Not all platforms support a read timeout; on
          platforms that don't, the read timeout is ignored.<DD><CODE>auth</CODE> - a pointer to a 'struct pcap_rmtauth' that keeps the information
          required to authenticate the user on a remote machine. In case
          this is not a remote capture, this pointer can be set to NULL.<DD><CODE>errbuf</CODE> - a pointer to a user-allocated buffer which will contain the error
          in case this function fails. The pcap_open() and findalldevs() are
          the only two functions which have this parameter, since they do
          not have (yet) a pointer to a pcap_t structure, which reserves
          space for the error string. Since these functions do not have
          (yet) a pcap_t pointer (the pcap_t pointer is NULL in case of
          errors), they need an explicit 'errbuf' variable. 'errbuf' may
          also be set to warning text when pcap_open_live() succeds; to
          detect this case the caller should store a zero-length string in
          'errbuf' before calling pcap_open_live() and display the warning
          to the user if 'errbuf' is no longer a zero-length string.
<DT><B>Returns:</B><DD>in case of problems, it returns null and the 'errbuf' variable
         keeps the error message.</DL>
</DD>
</DL>
<HR>

<A NAME="openDead(int, int)"><!-- --></A><H3>
openDead</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>openDead</B>(int&nbsp;linktype,
                               int&nbsp;snaplen)</PRE>
<DL>
<DD>Create a pcap_t structure without starting a capture. pcap_open_dead() is
 used for creating a pcap_t structure to use when calling the other
 functions in libpcap. It is typically used when just using libpcap for
 compiling BPF code.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>linktype</CODE> - pcap DLT link type integer value<DD><CODE>snaplen</CODE> - filters generated using the pcap structure will truncate captured
          packets to this length
<DT><B>Returns:</B><DD>WinPcap structure that can only be used to generate filter code and
         none of its other capture methods should be called or null if error
         occured<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#openDead(int, int)"><CODE>Pcap.openDead(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="openLive(java.lang.String, int, int, int, java.lang.Appendable)"><!-- --></A><H3>
openLive</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>openLive</B>(java.lang.String&nbsp;device,
                               int&nbsp;snaplen,
                               int&nbsp;promisc,
                               int&nbsp;timeout,
                               java.lang.Appendable&nbsp;errbuf)
                        throws java.io.IOException</PRE>
<DL>
<DD><p>
 This method, overrides the generic libpcap based <code>openLive</code>
 method, and allocates a peer pcap object that allows WinPcap extensions.
 </p>
 <p>
 Open a live capture associated with the specified network interface device.
 pcap_open_live() is used to obtain a packet capture descriptor to look at
 packets on the network. device is a string that specifies the network
 device to open; on Linux systems with 2.2 or later kernels, a device
 argument of "any" or NULL can be used to capture packets from all
 interfaces. snaplen specifies the maximum number of bytes to capture. If
 this value is less than the size of a packet that is captured, only the
 first snaplen bytes of that packet will be captured and provided as packet
 data. A value of 65535 should be sufficient, on most if not all networks,
 to capture all the data available from the packet. promisc specifies if the
 interface is to be put into promiscuous mode. (Note that even if this
 parameter is false, the interface could well be in promiscuous mode for
 some other reason.)
 </p>
 <p>
 For now, this doesn't work on the "any" device; if an argument of "any" or
 NULL is supplied, the promisc flag is ignored. to_ms specifies the read
 timeout in milliseconds. The read timeout is used to arrange that the read
 not necessarily return immediately when a packet is seen, but that it wait
 for some amount of time to allow more packets to arrive and to read
 multiple packets from the OS kernel in one operation. Not all platforms
 support a read timeout; on platforms that don't, the read timeout is
 ignored. A zero value for to_ms, on platforms that support a read timeout,
 will cause a read to wait forever to allow enough packets to arrive, with
 no timeout. errbuf is used to return error or warning text. It will be set
 to error text when pcap_open_live() fails and returns NULL. errbuf may also
 be set to warning text when pcap_open_live() succeds; to detect this case
 the caller should store a zero-length string in errbuf before calling
 pcap_open_live() and display the warning to the user if errbuf is no longer
 a zero-length string.
 </p>
 <p>
 <b>Special note about <code>snaplen</code> argument.</b> The behaviour of
 this argument may be suprizing to some. The <code>argument</code> is only
 applied when there is a filter set using <code>setFilter</code> method
 after the <code>openLive</code> call. Otherwise snaplen, even non zero is
 ignored. This is the behavior of all BSD systems utilizing BPF and WinPcap.
 This may change in the future, but that is the current behavior. (For more
 detailed explanation and discussion please see jNetPcap website and its
 FAQs.)
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - buffer containing a C, '\0' terminated string with the the name of
          the device<DD><CODE>snaplen</CODE> - amount of data to capture per packet; (see special note in doc
          comments about when this argument is ignored even when non-zero)<DD><CODE>promisc</CODE> - 1 means open in promiscious mode, a 0 means non-propmiscous<DD><CODE>timeout</CODE> - timeout in ms<DD><CODE>errbuf</CODE> - a buffer that will contain any error messages if the call to open
          failed
<DT><B>Returns:</B><DD>a raw structure the data of <code>pcap_t</code> C structure as
         returned by native libpcap call to open
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - Signals that an I/O exception has occurred.<DT><B>Since:</B></DT>
  <DD>1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><CODE>Pcap.openLive(String, int, int, int, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="openLive(java.lang.String, int, int, int, java.lang.StringBuffer)"><!-- --></A><H3>
openLive</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>openLive</B>(java.lang.String&nbsp;device,
                               int&nbsp;snaplen,
                               int&nbsp;promisc,
                               int&nbsp;timeout,
                               java.lang.StringBuffer&nbsp;errbuf)</PRE>
<DL>
<DD><p>
 This method, overrides the generic libpcap based <code>openLive</code>
 method, and allocates a peer pcap object that allows WinPcap extensions.
 </p>
 <p>
 Open a live capture associated with the specified network interface device.
 pcap_open_live() is used to obtain a packet capture descriptor to look at
 packets on the network. device is a string that specifies the network
 device to open; on Linux systems with 2.2 or later kernels, a device
 argument of "any" or NULL can be used to capture packets from all
 interfaces. snaplen specifies the maximum number of bytes to capture. If
 this value is less than the size of a packet that is captured, only the
 first snaplen bytes of that packet will be captured and provided as packet
 data. A value of 65535 should be sufficient, on most if not all networks,
 to capture all the data available from the packet. promisc specifies if the
 interface is to be put into promiscuous mode. (Note that even if this
 parameter is false, the interface could well be in promiscuous mode for
 some other reason.)
 </p>
 <p>
 For now, this doesn't work on the "any" device; if an argument of "any" or
 NULL is supplied, the promisc flag is ignored. to_ms specifies the read
 timeout in milliseconds. The read timeout is used to arrange that the read
 not necessarily return immediately when a packet is seen, but that it wait
 for some amount of time to allow more packets to arrive and to read
 multiple packets from the OS kernel in one operation. Not all platforms
 support a read timeout; on platforms that don't, the read timeout is
 ignored. A zero value for to_ms, on platforms that support a read timeout,
 will cause a read to wait forever to allow enough packets to arrive, with
 no timeout. errbuf is used to return error or warning text. It will be set
 to error text when pcap_open_live() fails and returns NULL. errbuf may also
 be set to warning text when pcap_open_live() succeds; to detect this case
 the caller should store a zero-length string in errbuf before calling
 pcap_open_live() and display the warning to the user if errbuf is no longer
 a zero-length string.
 </p>
 <p>
 <b>Special note about <code>snaplen</code> argument.</b> The behaviour of
 this argument may be suprizing to some. The <code>argument</code> is only
 applied when there is a filter set using <code>setFilter</code> method
 after the <code>openLive</code> call. Otherwise snaplen, even non zero is
 ignored. This is the behavior of all BSD systems utilizing BPF and WinPcap.
 This may change in the future, but that is the current behavior. (For more
 detailed explanation and discussion please see jNetPcap website and its
 FAQs.)
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - buffer containing a C, '\0' terminated string with the the name of
          the device<DD><CODE>snaplen</CODE> - amount of data to capture per packet; (see special note in doc
          comments about when this argument is ignored even when non-zero)<DD><CODE>promisc</CODE> - 1 means open in promiscious mode, a 0 means non-propmiscous<DD><CODE>timeout</CODE> - timeout in ms<DD><CODE>errbuf</CODE> - a buffer that will contain any error messages if the call to open
          failed
<DT><B>Returns:</B><DD>a raw structure the data of <code>pcap_t</code> C structure as
         returned by native libpcap call to open<DT><B>Since:</B></DT>
  <DD>1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><CODE>Pcap.openLive(String, int, int, int, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><!-- --></A><H3>
openLive</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>openLive</B>(java.lang.String&nbsp;device,
                               int&nbsp;snaplen,
                               int&nbsp;promisc,
                               int&nbsp;timeout,
                               java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD><p>
 This method, overrides the generic libpcap based <code>openLive</code>
 method, and allocates a peer pcap object that allows WinPcap extensions.
 </p>
 <p>
 Open a live capture associated with the specified network interface device.
 pcap_open_live() is used to obtain a packet capture descriptor to look at
 packets on the network. device is a string that specifies the network
 device to open; on Linux systems with 2.2 or later kernels, a device
 argument of "any" or NULL can be used to capture packets from all
 interfaces. snaplen specifies the maximum number of bytes to capture. If
 this value is less than the size of a packet that is captured, only the
 first snaplen bytes of that packet will be captured and provided as packet
 data. A value of 65535 should be sufficient, on most if not all networks,
 to capture all the data available from the packet. promisc specifies if the
 interface is to be put into promiscuous mode. (Note that even if this
 parameter is false, the interface could well be in promiscuous mode for
 some other reason.)
 </p>
 <p>
 For now, this doesn't work on the "any" device; if an argument of "any" or
 NULL is supplied, the promisc flag is ignored. to_ms specifies the read
 timeout in milliseconds. The read timeout is used to arrange that the read
 not necessarily return immediately when a packet is seen, but that it wait
 for some amount of time to allow more packets to arrive and to read
 multiple packets from the OS kernel in one operation. Not all platforms
 support a read timeout; on platforms that don't, the read timeout is
 ignored. A zero value for to_ms, on platforms that support a read timeout,
 will cause a read to wait forever to allow enough packets to arrive, with
 no timeout. errbuf is used to return error or warning text. It will be set
 to error text when pcap_open_live() fails and returns NULL. errbuf may also
 be set to warning text when pcap_open_live() succeds; to detect this case
 the caller should store a zero-length string in errbuf before calling
 pcap_open_live() and display the warning to the user if errbuf is no longer
 a zero-length string.
 </p>
 <p>
 <b>Special note about <code>snaplen</code> argument.</b> The behaviour of
 this argument may be suprizing to some. The <code>argument</code> is only
 applied when there is a filter set using <code>setFilter</code> method
 after the <code>openLive</code> call. Otherwise snaplen, even non zero is
 ignored. This is the behavior of all BSD systems utilizing BPF and WinPcap.
 This may change in the future, but that is the current behavior. (For more
 detailed explanation and discussion please see jNetPcap website and its
 FAQs.)
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - buffer containing a C, '\0' terminated string with the the name of
          the device<DD><CODE>snaplen</CODE> - amount of data to capture per packet; (see special note in doc
          comments about when this argument is ignored even when non-zero)<DD><CODE>promisc</CODE> - 1 means open in promiscious mode, a 0 means non-propmiscous<DD><CODE>timeout</CODE> - timeout in ms<DD><CODE>errbuf</CODE> - a buffer that will contain any error messages if the call to open
          failed
<DT><B>Returns:</B><DD>a raw structure the data of <code>pcap_t</code> C structure as
         returned by native libpcap call to open<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><CODE>Pcap.openLive(String, int, int, int, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="openOffline(java.lang.String, java.lang.Appendable)"><!-- --></A><H3>
openOffline</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>openOffline</B>(java.lang.String&nbsp;fname,
                                  java.lang.Appendable&nbsp;errbuf)
                           throws java.io.IOException</PRE>
<DL>
<DD>Open a savefile in the tcpdump/libpcap format to read packets.
 pcap_open_offline() is called to open a "savefile" for reading. fname
 specifies the name of the file to open. The file has the same format as
 those used by tcpdump(1) and tcpslice(1). The name "-" in a synonym for
 stdin. Alternatively, you may call pcap_fopen_offline() to read dumped data
 from an existing open stream fp. Note that on Windows, that stream should
 be opened in binary mode. errbuf is used to return error text and is only
 set when pcap_open_offline() or pcap_fopen_offline() fails and returns
 NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fname</CODE> - filename of the pcap file<DD><CODE>errbuf</CODE> - any error messages in UTC8 encoding
<DT><B>Returns:</B><DD>WinPcap structure or null if error occured
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - Signals that an I/O exception has occurred.<DT><B>Since:</B></DT>
  <DD>1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#openOffline(java.lang.String, java.lang.StringBuilder)"><CODE>Pcap.openOffline(String, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="openOffline(java.lang.String, java.lang.StringBuffer)"><!-- --></A><H3>
openOffline</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>openOffline</B>(java.lang.String&nbsp;fname,
                                  java.lang.StringBuffer&nbsp;errbuf)</PRE>
<DL>
<DD>Open a savefile in the tcpdump/libpcap format to read packets.
 pcap_open_offline() is called to open a "savefile" for reading. fname
 specifies the name of the file to open. The file has the same format as
 those used by tcpdump(1) and tcpslice(1). The name "-" in a synonym for
 stdin. Alternatively, you may call pcap_fopen_offline() to read dumped data
 from an existing open stream fp. Note that on Windows, that stream should
 be opened in binary mode. errbuf is used to return error text and is only
 set when pcap_open_offline() or pcap_fopen_offline() fails and returns
 NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fname</CODE> - filename of the pcap file<DD><CODE>errbuf</CODE> - any error messages in UTC8 encoding
<DT><B>Returns:</B><DD>WinPcap structure or null if error occured<DT><B>Since:</B></DT>
  <DD>1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#openOffline(java.lang.String, java.lang.StringBuilder)"><CODE>Pcap.openOffline(String, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="openOffline(java.lang.String, java.lang.StringBuilder)"><!-- --></A><H3>
openOffline</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A> <B>openOffline</B>(java.lang.String&nbsp;fname,
                                  java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>Open a savefile in the tcpdump/libpcap format to read packets.
 pcap_open_offline() is called to open a "savefile" for reading. fname
 specifies the name of the file to open. The file has the same format as
 those used by tcpdump(1) and tcpslice(1). The name "-" in a synonym for
 stdin. Alternatively, you may call pcap_fopen_offline() to read dumped data
 from an existing open stream fp. Note that on Windows, that stream should
 be opened in binary mode. errbuf is used to return error text and is only
 set when pcap_open_offline() or pcap_fopen_offline() fails and returns
 NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fname</CODE> - filename of the pcap file<DD><CODE>errbuf</CODE> - any error messages in UTC8 encoding
<DT><B>Returns:</B><DD>WinPcap structure or null if error occured<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#openOffline(java.lang.String, java.lang.StringBuilder)"><CODE>Pcap.openOffline(String, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sendQueueAlloc(int)"><!-- --></A><H3>
sendQueueAlloc</H3>
<PRE>
public static <A HREF="../../../org/jnetpcap/winpcap/WinPcapSendQueue.html" title="class in org.jnetpcap.winpcap">WinPcapSendQueue</A> <B>sendQueueAlloc</B>(int&nbsp;size)</PRE>
<DL>
<DD>Allocate a send queue. This method allocats a send queue, i.e. a buffer
 containing a set of raw packets that will be transmittted on the network
 with <A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)"><CODE>sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)</CODE></A> method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - size of the sendqueue to allocate
<DT><B>Returns:</B><DD>allocated sendqueue<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)"><CODE>sendQueueTransmit(WinPcapSendQueue, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sendQueueDestroy(org.jnetpcap.winpcap.WinPcapSendQueue)"><!-- --></A><H3>
sendQueueDestroy</H3>
<PRE>
public static void <B>sendQueueDestroy</B>(<A HREF="../../../org/jnetpcap/winpcap/WinPcapSendQueue.html" title="class in org.jnetpcap.winpcap">WinPcapSendQueue</A>&nbsp;queue)</PRE>
<DL>
<DD>Destroy a send queue. Deletes a send queue and frees all the memory
 associated with it.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>queue</CODE> - the queue to free up</DL>
</DD>
</DL>
<HR>

<A NAME="liveDump(java.lang.String, int, int)"><!-- --></A><H3>
liveDump</H3>
<PRE>
public int <B>liveDump</B>(java.lang.String&nbsp;fname,
                    int&nbsp;maxsize,
                    int&nbsp;maxpackets)</PRE>
<DL>
<DD>dumps the network traffic from an interface to a file. Using this function
 the dump is performed at kernel level, therefore it is more efficient than
 using Pcap.dump(). The parameters of this function are an interface
 descriptor (obtained with openLive()), a string with the name of the dump
 file, the maximum size of the file (in bytes) and the maximum number of
 packets that the file will contain. Setting maxsize or maxpacks to 0 means
 no limit. When maxsize or maxpacks are reached, the dump ends. liveDump()
 is non-blocking, threfore Return immediately. liveDumpEnded() can be used
 to check the status of the dump process or to wait until it is finished.
 Pcap.close() can instead be used to end the dump process. Note that when
 one of the two limits is reached, the dump is stopped, but the file remains
 opened. In order to correctly flush the data and put the file in a
 consistent state, the adapter must be closed with Pcap.close().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fname</CODE> - file name<DD><CODE>maxsize</CODE> - maximum file size<DD><CODE>maxpackets</CODE> - maximum number of packets to store
<DT><B>Returns:</B><DD>0 on success otherwise -1</DL>
</DD>
</DL>
<HR>

<A NAME="liveDumpEnded(int)"><!-- --></A><H3>
liveDumpEnded</H3>
<PRE>
public int <B>liveDumpEnded</B>(int&nbsp;sync)</PRE>
<DL>
<DD>Return the status of the kernel dump process, i.e. tells if one of the
 limits defined with pcap_live_dump() has been reached.
 pcap_live_dump_ended() informs the user about the limits that were set with
 a previous call to pcap_live_dump() on the interface pointed by p: if the
 return value is nonzero, one of the limits has been reched and the dump
 process is currently stopped. If sync is nonzero, the function blocks until
 the dump is finished, otherwise Return immediately. Warning: if the dump
 process has no limits (i.e. if the maxsize and maxpacks arguments of
 pcap_live_dump() were both 0), the dump process will never stop, therefore
 setting sync to TRUE will block the application on this call forever.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sync</CODE> - if sync is nonzero, the function blocks until the dump is
          finished, otherwise returns immediately
<DT><B>Returns:</B><DD>non zero value means that dump process has finished, a zero means
         its still in progress</DL>
</DD>
</DL>
<HR>

<A NAME="sendQueueTransmit(org.jnetpcap.winpcap.WinPcapSendQueue, int)"><!-- --></A><H3>
sendQueueTransmit</H3>
<PRE>
public int <B>sendQueueTransmit</B>(<A HREF="../../../org/jnetpcap/winpcap/WinPcapSendQueue.html" title="class in org.jnetpcap.winpcap">WinPcapSendQueue</A>&nbsp;queue,
                             int&nbsp;synch)</PRE>
<DL>
<DD>Send a queue of raw packets to the network. This function transmits the
 content of a queue to the wire. p is a pointer to the adapter on which the
 packets will be sent, queue points to a pcap_send_queue structure
 containing the packets to send (see pcap_sendqueue_alloc() and
 pcap_sendqueue_queue()), sync determines if the send operation must be
 synchronized: if it is non-zero, the packets are sent respecting the
 timestamps, otherwise they are sent as fast as possible. The return value
 is the amount of bytes actually sent. If it is smaller than the size
 parameter, an error occurred during the send. The error can be caused by a
 driver/adapter problem or by an inconsistent/bogus send queue. Note: Using
 this function is more efficient than issuing a series of pcap_sendpacket(),
 because the packets are buffered in the kernel driver, so the number of
 context switches is reduced. Therefore, expect a better throughput when
 using pcap_sendqueue_transmit. When Sync is set to TRUE, the packets are
 synchronized in the kernel with a high precision timestamp. This requires a
 non-negligible amount of CPU, but allows normally to send the packets with
 a precision of some microseconds (depending on the accuracy of the
 performance counter of the machine). Such a precision cannot be reached
 sending the packets with pcap_sendpacket().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>queue</CODE> - queue containing the data to be sent<DD><CODE>synch</CODE> - if it is non-zero, the packets are sent respecting the timestamps,
          otherwise they are sent as fast as possible
<DT><B>Returns:</B><DD>amount of bytes actually sent; error if less then queues len
         parameter</DL>
</DD>
</DL>
<HR>

<A NAME="setBuff(int)"><!-- --></A><H3>
setBuff</H3>
<PRE>
public int <B>setBuff</B>(int&nbsp;dim)</PRE>
<DL>
<DD>Set the size of the kernel buffer associated with an adapter. If an old
 buffer was already created with a previous call to pcap_setbuff(), it is
 deleted and its content is discarded. pcap_open_live() creates a 1 MByte
 buffer by default.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dim</CODE> - specifies the size of the buffer in bytes
<DT><B>Returns:</B><DD>the return value is 0 when the call succeeds, -1 otherwise<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuffer)"><CODE>openLive(String, int, int, int, StringBuffer)</CODE></A>, 
<A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.PcapHandler, T)"><CODE>Pcap.loop(int, PcapHandler, Object)</CODE></A>, 
<A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.PcapHandler, T)"><CODE>Pcap.dispatch(int, PcapHandler, Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMinToCopy(int)"><!-- --></A><H3>
setMinToCopy</H3>
<PRE>
public int <B>setMinToCopy</B>(int&nbsp;size)</PRE>
<DL>
<DD>Set the minumum amount of data received by the kernel in a single call.
 pcap_setmintocopy() changes the minimum amount of data in the kernel buffer
 that causes a read from the application to return (unless the timeout
 expires). If the value of size is large, the kernel is forced to wait the
 arrival of several packets before copying the data to the user. This
 guarantees a low number of system calls, i.e. low processor usage, and is a
 good setting for applications like packet-sniffers and protocol analyzers.
 Vice versa, in presence of a small value for this variable, the kernel will
 copy the packets as soon as the application is ready to receive them. This
 is useful for real time applications that need the best responsiveness from
 the kernel.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - minimum size
<DT><B>Returns:</B><DD>the return value is 0 when the call succeeds, -1 otherwise<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/winpcap/WinPcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuffer)"><CODE>openLive(String, int, int, int, StringBuffer)</CODE></A>, 
<A HREF="../../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.PcapHandler, T)"><CODE>Pcap.loop(int, PcapHandler, Object)</CODE></A>, 
<A HREF="../../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.PcapHandler, T)"><CODE>Pcap.dispatch(int, PcapHandler, Object)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMode(int)"><!-- --></A><H3>
setMode</H3>
<PRE>
public int <B>setMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Set the working mode of the interface p to mode. Valid values for mode are
 MODE_CAPT (default capture mode) and MODE_STAT (statistical mode).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - pcap capture mode
<DT><B>Returns:</B><DD>the return value is 0 when the call succeeds, -1 otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="setSampling()"><!-- --></A><H3>
setSampling</H3>
<PRE>
public <A HREF="../../../org/jnetpcap/winpcap/WinPcapSamp.html" title="class in org.jnetpcap.winpcap">WinPcapSamp</A> <B>setSampling</B>()</PRE>
<DL>
<DD><p>
 Define a sampling method for packet capture. This function allows applying
 a sampling method to the packet capture process. The currently sampling
 methods (and the way to set them) are described into the struct pcap_samp.
 In other words, the user must set the appropriate parameters into it; these
 will be applied as soon as the capture starts.
 </p>
 <p>
 Warning:<br>
 Sampling parameters cannot be changed when a capture is active. These
 parameters must be applied before starting the capture. If they are applied
 when the capture is in progress, the new settings are ignored. Sampling
 works only when capturing data on Win32 or reading from a file. It has not
 been implemented on other platforms. Sampling works on remote machines
 provided that the probe (i.e. the capturing device) is a Win32 workstation.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an object through which you can change the capture algorithm</DL>
</DD>
</DL>
<HR>

<A NAME="statsEx()"><!-- --></A><H3>
statsEx</H3>
<PRE>
public <A HREF="../../../org/jnetpcap/winpcap/WinPcapStat.html" title="class in org.jnetpcap.winpcap">WinPcapStat</A> <B>statsEx</B>()</PRE>
<DL>
<DD>This method extends the <code>Pcap.stats</code> method and allows more
 statistics to be returned. Note, the signature of this method deviates
 slightly from WinPcap implementation due to programming differences of
 java. There is no need to deallocate any structures.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the win pcap stat<DT><B>See Also:</B><DD><A HREF="../../../org/jnetpcap/Pcap.html#stats(org.jnetpcap.PcapStat)"><CODE>return stats structure which is
      filled with statistics or null on error</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/winpcap/WinPcapRmtAuth.html" title="class in org.jnetpcap.winpcap"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/winpcap/WinPcap.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="WinPcap.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
