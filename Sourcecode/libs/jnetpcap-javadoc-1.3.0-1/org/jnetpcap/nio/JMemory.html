<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_07) on Sat Apr 02 12:55:25 EDT 2011 -->
<TITLE>
JMemory
</TITLE>

<META NAME="date" CONTENT="2011-04-02">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JMemory";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jnetpcap/nio/JFunction.html" title="class in org.jnetpcap.nio"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/nio/JMemory.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JMemory.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.jnetpcap.nio</FONT>
<BR>
Class JMemory</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.jnetpcap.nio.JMemory</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>, <A HREF="../../../org/jnetpcap/nio/JFunction.html" title="class in org.jnetpcap.nio">JFunction</A>, <A HREF="../../../org/jnetpcap/nio/JMemoryPool.Block.html" title="class in org.jnetpcap.nio">JMemoryPool.Block</A>, <A HREF="../../../org/jnetpcap/nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</A>, <A HREF="../../../org/jnetpcap/nio/JStruct.html" title="class in org.jnetpcap.nio">JStruct</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>JMemory</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
A base class for all other PEERED classes to native c structures. The class
 only contains the physical address of the native C structure. The class also
 contains a couple of convenience methods for allocating memory for the
 structure to be peered as well as doing cleanup and freeing up that memory
 when object is finalized().
 <p>
 This is one of the most important classes within jNetPcap library. It is
 responsible for most of the memory allocation and management behind the
 scenes of all jNetPcap native methods.
 </p>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.2</DD>
<DT><B>Author:</B></DT>
  <DD>Mark Bednarczyk, Sly Technologies, Inc.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Used in special memory allocation.</TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#JNETPCAP_LIBRARY_NAME">JNETPCAP_LIBRARY_NAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name of the native library that wraps around libpcap and extensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#MAX_DIRECT_MEMORY_DEFAULT">MAX_DIRECT_MEMORY_DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default maximum value for 'nio.mx' system property, if not set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#POINTER">POINTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convenience constant that is synonym as JMemory.Type.POINTER.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#JMemory(java.nio.ByteBuffer)">JMemory</A></B>(java.nio.ByteBuffer&nbsp;peer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instantiates a new j memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#JMemory(int)">JMemory</A></B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pre-allocates memory for any structures the subclass may need to use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#JMemory(org.jnetpcap.nio.JMemory.Type)">JMemory</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A>&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No memory pre-allocation constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#JMemory(org.jnetpcap.nio.JMemory)">JMemory</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a deep copy into a newly allocated memory block.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#availableDirectMemory()">availableDirectMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns how much native memory is available for allocation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#check()">check</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if this peered object is initialized.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#cleanup()">cleanup</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Called to clean up and release any allocated memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../org/jnetpcap/nio/JMemoryReference.html" title="class in org.jnetpcap.nio">JMemoryReference</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#createReference(long, long)">createReference</A></B>(long&nbsp;address,
                long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a cleanup/dispose weak reference object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#isInitialized()">isInitialized</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if this peered object is initialized.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#isJMemoryBasedOwner()">isJMemoryBasedOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if physical memory pointed to by this object, is owned either by
 this JMemory based object or the actual owner is also JMemory based.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#isOwner()">isOwner</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if this object is the owner of native memory</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#maxDirectMemory()">maxDirectMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hard limit for the amount of memory native is allowed to
 allocate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#peer(java.nio.ByteBuffer)">peer</A></B>(java.nio.ByteBuffer&nbsp;peer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peers the src structure with this instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#peer(org.jnetpcap.nio.JMemory)">peer</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;peer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peers the peer structure with this instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#peer(org.jnetpcap.nio.JMemory, int, int)">peer</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;peer,
     int&nbsp;offset,
     int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peers the peer structure with this instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#reservedDirectMemory()">reservedDirectMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns how much native memory has be used so far.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#setSize(int)">setSize</A></B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes the size of the current memory buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the size of the memory block that this peered structure is point
 to.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#softDirectMemory()">softDirectMemory</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the soft limit for native memory allocation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#toDebugString()">toDebugString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a debug string about this JMemory state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#toHexdump()">toHexdump</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A debug method, similar to toString() which converts the contents of the
 memory to textual hexdump.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#toHexdump(int, boolean, boolean, boolean)">toHexdump</A></B>(int&nbsp;length,
          boolean&nbsp;address,
          boolean&nbsp;text,
          boolean&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A debug method, similar to toString() which converts the contents of the
 memory to textual hexdump.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#totalActiveAllocated()">totalActiveAllocated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the total number of active native memory bytes currently allocated
 that have not been deallocated as of yet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocateCalls()">totalAllocateCalls</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns total number of allocate calls through JMemory class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocated()">totalAllocated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns total number of bytes allocated through JMemory class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocatedSegments0To255Bytes()">totalAllocatedSegments0To255Bytes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of memory segments that were allocated by JMemory class
 in the range of 0 to 255 bytes in size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#totalAllocatedSegments256OrAbove()">totalAllocatedSegments256OrAbove</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of memory segments that were allocated by JMemory class
 in the range of 256 bytes or above in size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#totalDeAllocateCalls()">totalDeAllocateCalls</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns total number of deallocate calls through JMemory class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#totalDeAllocated()">totalDeAllocated</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns total number of bytes deallocated through JMemory class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFrom(byte[])">transferFrom</A></B>(byte[]&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies contents of byte array to memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFrom(byte[], int, int, int)">transferFrom</A></B>(byte[]&nbsp;buffer,
             int&nbsp;srcOffset,
             int&nbsp;length,
             int&nbsp;dstOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies contents of byte array to memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFrom(java.nio.ByteBuffer)">transferFrom</A></B>(java.nio.ByteBuffer&nbsp;src)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data from memory from direct byte buffer to this memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFrom(java.nio.ByteBuffer, int)">transferFrom</A></B>(java.nio.ByteBuffer&nbsp;src,
             int&nbsp;dstOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data from memory from direct byte buffer to this memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferFromDirect(java.nio.ByteBuffer, int)">transferFromDirect</A></B>(java.nio.ByteBuffer&nbsp;src,
                   int&nbsp;dstOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data from memory from direct byte buffer to this memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferOwnership(org.jnetpcap.nio.JMemory)">transferOwnership</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;memory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A special method that allows one object to transfer ownership of a memory
 block.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(byte[])">transferTo</A></B>(byte[]&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data from memory to byte array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(byte[], int, int, int)">transferTo</A></B>(byte[]&nbsp;buffer,
           int&nbsp;srcOffset,
           int&nbsp;length,
           int&nbsp;dstOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies data from memory to byte array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(java.nio.ByteBuffer)">transferTo</A></B>(java.nio.ByteBuffer&nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies teh contents of this memory to buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(java.nio.ByteBuffer, int, int)">transferTo</A></B>(java.nio.ByteBuffer&nbsp;dst,
           int&nbsp;srcOffset,
           int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies teh contents of this memory to buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(org.jnetpcap.nio.JBuffer, int, int, int)">transferTo</A></B>(<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;dst,
           int&nbsp;srcOffset,
           int&nbsp;length,
           int&nbsp;dstOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transfers the contents of this memory to buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(org.jnetpcap.nio.JMemory)">transferTo</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copied the entire contents of this memory to destination memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo(org.jnetpcap.nio.JMemory, int, int, int)">transferTo</A></B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;dst,
           int&nbsp;srcOffset,
           int&nbsp;length,
           int&nbsp;dstOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copied the entire contents of this memory to destination memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/jnetpcap/nio/JMemory.html#transferTo0(long, byte[], int, int, int)">transferTo0</A></B>(long&nbsp;address,
            byte[]&nbsp;buffer,
            int&nbsp;srcOffset,
            int&nbsp;length,
            int&nbsp;dstOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transfer to0.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JNETPCAP_LIBRARY_NAME"><!-- --></A><H3>
JNETPCAP_LIBRARY_NAME</H3>
<PRE>
public static final java.lang.String <B>JNETPCAP_LIBRARY_NAME</B></PRE>
<DL>
<DD>Name of the native library that wraps around libpcap and extensions.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.nio.JMemory.JNETPCAP_LIBRARY_NAME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MAX_DIRECT_MEMORY_DEFAULT"><!-- --></A><H3>
MAX_DIRECT_MEMORY_DEFAULT</H3>
<PRE>
public static final long <B>MAX_DIRECT_MEMORY_DEFAULT</B></PRE>
<DL>
<DD>The default maximum value for 'nio.mx' system property, if not set. The
 actual runtime default value for 'nio.mx' property is calculated to be the
 lower of either <A HREF="../../../org/jnetpcap/nio/JMemory.html#MAX_DIRECT_MEMORY_DEFAULT"><CODE>MAX_DIRECT_MEMORY_DEFAULT</CODE></A> constant or the value
 specified on the JVM command line using '-Xmx<size>' option.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.jnetpcap.nio.JMemory.MAX_DIRECT_MEMORY_DEFAULT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="POINTER"><!-- --></A><H3>
POINTER</H3>
<PRE>
public static final <A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A> <B>POINTER</B></PRE>
<DL>
<DD>Convenience constant that is synonym as JMemory.Type.POINTER. Since this
 type constant is used so often, it is made as a in-class constant to make
 it easier to access.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JMemory(java.nio.ByteBuffer)"><!-- --></A><H3>
JMemory</H3>
<PRE>
public <B>JMemory</B>(java.nio.ByteBuffer&nbsp;peer)</PRE>
<DL>
<DD>Instantiates a new j memory.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>peer</CODE> - the peer</DL>
</DL>
<HR>

<A NAME="JMemory(int)"><!-- --></A><H3>
JMemory</H3>
<PRE>
public <B>JMemory</B>(int&nbsp;size)</PRE>
<DL>
<DD>Pre-allocates memory for any structures the subclass may need to use.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - number of bytes to pre-allocate allocate</DL>
</DL>
<HR>

<A NAME="JMemory(org.jnetpcap.nio.JMemory)"><!-- --></A><H3>
JMemory</H3>
<PRE>
public <B>JMemory</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;src)</PRE>
<DL>
<DD>Performs a deep copy into a newly allocated memory block.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the src</DL>
</DL>
<HR>

<A NAME="JMemory(org.jnetpcap.nio.JMemory.Type)"><!-- --></A><H3>
JMemory</H3>
<PRE>
public <B>JMemory</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio">JMemory.Type</A>&nbsp;type)</PRE>
<DL>
<DD>No memory pre-allocation constructor.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - type of memory allocation model</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="availableDirectMemory()"><!-- --></A><H3>
availableDirectMemory</H3>
<PRE>
public static long <B>availableDirectMemory</B>()</PRE>
<DL>
<DD>Returns how much native memory is available for allocation. This is a limit
 set by method <A HREF="../../../org/jnetpcap/nio/JMemory.html#setMaxDirectMemorySize(long)"><CODE>setMaxDirectMemorySize(long)</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the difference between maxDirectMemory and reservedDirectMemory</DL>
</DD>
</DL>
<HR>

<A NAME="maxDirectMemory()"><!-- --></A><H3>
maxDirectMemory</H3>
<PRE>
public static long <B>maxDirectMemory</B>()</PRE>
<DL>
<DD>Returns the hard limit for the amount of memory native is allowed to
 allocate. The memory setting defaults to JVMs max memory which can be
 specified with JVM command line option '-Xmx&lt;size&gt;.Once the 'nio.mx'
 limit is reached, the allocating thread is blocked and a JVM GC request is
 issued. The allocating thread continues to wait, until sufficient minimum
 amount (Default: DisposableGC#MIN_MEMORY_RELEASE)of native
 memory was cleaned up or a timeout (Default:
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the limit in number of bytes
         DisposableGC#OUT_OF_MEMORY_TIMEOUT ms) occurs.
         <p>
         This limit can be set at startup of the application using the
         following system properties, which are checked in the order listed
         below:
         <ol>
         <li><code>org.jnetsoft.nio.MaxDirectMemorySize</code>
         <li><code>nio.MaxDirectMemorySize</code>
         <li><code>org.jnetsoft.nio.mx</code>
         <li><code>nio.mx</code>
         </ol>
         The different property names, from the most fully qualified to the
         least, are provided to property name conflict resolution. For
         convenience, it is recommended that the user choose the least
         qualified property name to use. In the unlikely event that another
         library within the same runtime application uses the same property
         name, one of the more qualified (or longer) property names can be
         used to resolve the conflict.
         </p></DL>
</DD>
</DL>
<HR>

<A NAME="reservedDirectMemory()"><!-- --></A><H3>
reservedDirectMemory</H3>
<PRE>
public static long <B>reservedDirectMemory</B>()</PRE>
<DL>
<DD>Returns how much native memory has be used so far.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>amount of memory reserved/allocated at this moment</DL>
</DD>
</DL>
<HR>

<A NAME="softDirectMemory()"><!-- --></A><H3>
softDirectMemory</H3>
<PRE>
public static long <B>softDirectMemory</B>()</PRE>
<DL>
<DD>Returns the soft limit for native memory allocation. When the soft memory
 allocation limit is reached, memory continues to be allocated without
 interruption or blocking. At the same the a JVM GC request is issued to
 start collecting unused objects and potentially cleanup memory. The JVM GC
 request may be repeated while the current memory allocation is above this
 soft limit, but is limited to a minimum delay between consecutive JVM GC
 requests. This process continues until memory allocation falls below this
 soft limit or the hard 'nio.mx' limit is reached.
 <p>
 This limit can be set at startup of the application using the following
 system properties, which are checked in the order listed below:
 <ol>
 <li><code>org.jnetsoft.nio.SoftDirectMemorySize</code>
 <li><code>nio.SoftDirectMemorySize</code>
 <li><code>org.jnetsoft.nio.ms</code>
 <li><code>nio.ms</code>
 </ol>
 The different property names, from the most fully qualified to the least,
 are provided to property name conflict resolution. For convenience, it is
 recommended that the user choose the least qualified property name to use.
 In the unlikely event that another library within the same runtime
 application uses the same property name, one of the more qualified (or
 longer) property names can be used to resolve the conflict.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the amount of memory, in bytes, before we start requesting a
         forcible JVM GC.</DL>
</DD>
</DL>
<HR>

<A NAME="totalActiveAllocated()"><!-- --></A><H3>
totalActiveAllocated</H3>
<PRE>
public static long <B>totalActiveAllocated</B>()</PRE>
<DL>
<DD>Returns the total number of active native memory bytes currently allocated
 that have not been deallocated as of yet. This number can be calculated by
 the following formula:
 
 <pre>
 totalAllocated() - totalDeAllocated()
 </pre>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>number of native memory bytes still allocated</DL>
</DD>
</DL>
<HR>

<A NAME="totalAllocateCalls()"><!-- --></A><H3>
totalAllocateCalls</H3>
<PRE>
public static long <B>totalAllocateCalls</B>()</PRE>
<DL>
<DD>Returns total number of allocate calls through JMemory class. The memory is
 allocated by JMemory class using native "malloc" calls and is not normally
 reported by JRE memory usage.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>total number of function calls made to malloc since JMemory class
         was loaded into memory</DL>
</DD>
</DL>
<HR>

<A NAME="totalAllocated()"><!-- --></A><H3>
totalAllocated</H3>
<PRE>
public static long <B>totalAllocated</B>()</PRE>
<DL>
<DD>Returns total number of bytes allocated through JMemory class. The memory
 is allocated by JMemory class using native "malloc" calls and is not
 normally reported by JRE memory usage.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>total number of bytes allocated since JMemory class was loaded into
         memory</DL>
</DD>
</DL>
<HR>

<A NAME="totalAllocatedSegments0To255Bytes()"><!-- --></A><H3>
totalAllocatedSegments0To255Bytes</H3>
<PRE>
public static long <B>totalAllocatedSegments0To255Bytes</B>()</PRE>
<DL>
<DD>Returns the number of memory segments that were allocated by JMemory class
 in the range of 0 to 255 bytes in size. This is number of segments, not
 amount of memory allocated.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the total number of memory segments in this size</DL>
</DD>
</DL>
<HR>

<A NAME="totalAllocatedSegments256OrAbove()"><!-- --></A><H3>
totalAllocatedSegments256OrAbove</H3>
<PRE>
public static long <B>totalAllocatedSegments256OrAbove</B>()</PRE>
<DL>
<DD>Returns the number of memory segments that were allocated by JMemory class
 in the range of 256 bytes or above in size. This is number of segments, not
 amount of memory allocated.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the total number of memory segments in this size</DL>
</DD>
</DL>
<HR>

<A NAME="totalDeAllocateCalls()"><!-- --></A><H3>
totalDeAllocateCalls</H3>
<PRE>
public static long <B>totalDeAllocateCalls</B>()</PRE>
<DL>
<DD>Returns total number of deallocate calls through JMemory class. The memory
 is allocated by JMemory class using native "free" calls and is not normally
 reported by JRE memory usage.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>total number of function calls made to free since JMemory class was
         loaded into memory</DL>
</DD>
</DL>
<HR>

<A NAME="totalDeAllocated()"><!-- --></A><H3>
totalDeAllocated</H3>
<PRE>
public static long <B>totalDeAllocated</B>()</PRE>
<DL>
<DD>Returns total number of bytes deallocated through JMemory class. The memory
 is deallocated by JMemory class using native "free" calls and is not
 normally reported by JRE memory usage.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>total number of bytes deallocated since JMemory class was loaded
         into memory</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo0(long, byte[], int, int, int)"><!-- --></A><H3>
transferTo0</H3>
<PRE>
protected static int <B>transferTo0</B>(long&nbsp;address,
                                 byte[]&nbsp;buffer,
                                 int&nbsp;srcOffset,
                                 int&nbsp;length,
                                 int&nbsp;dstOffset)</PRE>
<DL>
<DD>Transfer to0.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>address</CODE> - the address<DD><CODE>buffer</CODE> - the buffer<DD><CODE>srcOffset</CODE> - the src offset<DD><CODE>length</CODE> - the length<DD><CODE>dstOffset</CODE> - the dst offset
<DT><B>Returns:</B><DD>the int</DL>
</DD>
</DL>
<HR>

<A NAME="check()"><!-- --></A><H3>
check</H3>
<PRE>
public void <B>check</B>()
           throws java.lang.IllegalStateException</PRE>
<DL>
<DD>Checks if this peered object is initialized. This method throws
 IllegalStateException if not initialized and does not return any values.
 Its intended to as an assert mechanism
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if peered object is not initialized this unchecked exception will
           be thrown, otherwise it will exit silently</DL>
</DD>
</DL>
<HR>

<A NAME="cleanup()"><!-- --></A><H3>
cleanup</H3>
<PRE>
protected void <B>cleanup</B>()</PRE>
<DL>
<DD>Called to clean up and release any allocated memory. This method should be
 overriden if the allocated memory is not simply a single memory block and
 something more complex. This method is safe to call at anytime even if the
 object does not hold any allocated memory or is not the owner of the memory
 it is peered with. The method will reset this object to orignal unpeered
 state releasing any allocated and own memory at the same time if
 neccessary.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createReference(long, long)"><!-- --></A><H3>
createReference</H3>
<PRE>
protected <A HREF="../../../org/jnetpcap/nio/JMemoryReference.html" title="class in org.jnetpcap.nio">JMemoryReference</A> <B>createReference</B>(long&nbsp;address,
                                           long&nbsp;size)</PRE>
<DL>
<DD>Creates a cleanup/dispose weak reference object. This reference object is
 responsible for cleanup, after the actual JMemory object is garbage
 collected. After this object is garbage collected, the dispose method on
 the returned JMemoryReference object will be called at some point, when
 this object on longer exists, to cleanup. All JMemoryReferences contain a
 native memory pointer to the memory that potentially needs cleanup and
 disposal.
 <p>
 This method is protected and allows subclasses to provide their own cleanup
 code. If this method is not overriden, it will return a JMemoryReference
 object suitable to cleanup after this memory object.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>address</CODE> - native memory address to use in the disposable<DD><CODE>size</CODE> - the size
<DT><B>Returns:</B><DD>a reference that is tied to this JMemory object</DL>
</DD>
</DL>
<HR>

<A NAME="isInitialized()"><!-- --></A><H3>
isInitialized</H3>
<PRE>
public boolean <B>isInitialized</B>()</PRE>
<DL>
<DD>Checks if this peered object is initialized. This method does not throw any
 exceptions.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>if initialized true is returned, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="isJMemoryBasedOwner()"><!-- --></A><H3>
isJMemoryBasedOwner</H3>
<PRE>
public boolean <B>isJMemoryBasedOwner</B>()</PRE>
<DL>
<DD>Checks if physical memory pointed to by this object, is owned either by
 this JMemory based object or the actual owner is also JMemory based. This
 method provides a check if the physical memory pointed to by this object
 has been allocated through use of one of JMemory based functions or outside
 its memory management scope. For example, memory allocated by libpcap
 library will return false. While packets that copied their state to new
 memory will return true.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if physical memory is managed by JMemory, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="isOwner()"><!-- --></A><H3>
isOwner</H3>
<PRE>
public final boolean <B>isOwner</B>()</PRE>
<DL>
<DD>Checks if this object is the owner of native memory
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if this object is the owner, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="peer(java.nio.ByteBuffer)"><!-- --></A><H3>
peer</H3>
<PRE>
protected int <B>peer</B>(java.nio.ByteBuffer&nbsp;peer)
            throws <A HREF="../../../org/jnetpcap/packet/PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</A></PRE>
<DL>
<DD>Peers the src structure with this instance. The physical memory that the
 src peered object points to is set to this instance. The owner flag is not
 copied and src remains at the same state as it did before. This instance
 does not become the owner of the memory.
 <p>
 Further more, since we are peering with a ByteBuffer, the actual memory
 that is peered is between ByteBuffer's position and limit properties. Those
 2 properties determine which portion of the memory that will be peered.
 This allows a larger ByteBuffer to be peered with different objects
 providing rudimentary memory allocation mechanism.
 </p>
 <p>
 Lastly care must be taken, to ensure that the lifespans do not conflict.
 The memory that we are peering to must not be deallocated prior the
 termination of the lifespan of this object or at minimum calling
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>peer</CODE> - The ByteBuffer whose allocated native memory we want to peer with.
          The ByteByffer must be if direct buffer type which can be checked
          using ByteBuffer.isDirect() call.
<DT><B>Returns:</B><DD>the int
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../org/jnetpcap/packet/PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</A></CODE> - the peering exception <A HREF="../../../org/jnetpcap/nio/JMemory.html#cleanup()"><CODE>cleanup()</CODE></A> method to ensure that
           this object no longer references memory which may have been or
           become deallocated.
           </p><DT><B>See Also:</B><DD><CODE>ByteBuffer.isDirect()</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="peer(org.jnetpcap.nio.JMemory)"><!-- --></A><H3>
peer</H3>
<PRE>
protected int <B>peer</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;peer)</PRE>
<DL>
<DD>Peers the peer structure with this instance. The physical memory that the
 peer object points to is set to this instance. The owner flag is not copied
 and peer remains at the same state as it did before. This instance does not
 become the owner of the memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>peer</CODE> - the object whose allocated native memory we want to peer with
<DT><B>Returns:</B><DD>the int</DL>
</DD>
</DL>
<HR>

<A NAME="peer(org.jnetpcap.nio.JMemory, int, int)"><!-- --></A><H3>
peer</H3>
<PRE>
protected int <B>peer</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;peer,
                   int&nbsp;offset,
                   int&nbsp;length)
            throws java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Peers the peer structure with this instance. The physical memory that the
 peer object points to is set to this instance. The owner flag is not copied
 and peer remains at the same state as it did before. This instance does not
 become the owner of the memory. The function allows peering to a sub
 portion of the peer given the specified offset and length. The function
 strictly checks and inforces the bounds of the request to guarrantee that
 peer is not allowed to access physical memory outside of actual peer range.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>peer</CODE> - object memory block to peer with<DD><CODE>offset</CODE> - offset into the memory block<DD><CODE>length</CODE> - amount of memory to peer with
<DT><B>Returns:</B><DD>the int
<DT><B>Throws:</B>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the specified memory offset and length have negative or out of
           bounds of peer objects address space</DL>
</DD>
</DL>
<HR>

<A NAME="setSize(int)"><!-- --></A><H3>
setSize</H3>
<PRE>
public void <B>setSize</B>(int&nbsp;size)</PRE>
<DL>
<DD>Changes the size of the current memory buffer. The size can only be reduced
 in length and can not grow. The method throws exceptions if size parameter
 is greater then current size or negative.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - size in bytes that is smaller then existing size</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD>Returns the size of the memory block that this peered structure is point
 to. This object does not neccessarily have to be the owner of the memory
 block and could simply be a portion of the over all memory block.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>number of byte currently allocated</DL>
</DD>
</DL>
<HR>

<A NAME="toDebugString()"><!-- --></A><H3>
toDebugString</H3>
<PRE>
public java.lang.String <B>toDebugString</B>()</PRE>
<DL>
<DD>Returns a debug string about this JMemory state. Example:
 
 <pre>
 JMemory@b052fa8: size=1506, owner=nio.JMemoryPool$Block.class(size=10240/offset=4064)
 </pre>
 
 <ul>
 <li>hex nuber, is physical memory location
 <li>size = number of bytes of this memory object
 <li>owner = the class name of the object that owns the physical memory
 <li>isOwner = if true, means that this object is the owner of physical
 memory
 <li>size in parenthesis = the size of the physical memory allocated by the
 owner
 <li>offset in parenthesis = the offset into the physical memory block of
 this memory object
 </ul>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a summary string describing the state of this memory object</DL>
</DD>
</DL>
<HR>

<A NAME="toHexdump()"><!-- --></A><H3>
toHexdump</H3>
<PRE>
public java.lang.String <B>toHexdump</B>()</PRE>
<DL>
<DD>A debug method, similar to toString() which converts the contents of the
 memory to textual hexdump.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>multi-line hexdump of the entire memory region</DL>
</DD>
</DL>
<HR>

<A NAME="toHexdump(int, boolean, boolean, boolean)"><!-- --></A><H3>
toHexdump</H3>
<PRE>
public java.lang.String <B>toHexdump</B>(int&nbsp;length,
                                  boolean&nbsp;address,
                                  boolean&nbsp;text,
                                  boolean&nbsp;data)</PRE>
<DL>
<DD>A debug method, similar to toString() which converts the contents of the
 memory to textual hexdump.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>length</CODE> - maximum number of bytes to dump to hex output<DD><CODE>address</CODE> - flag if set to true will print out address offset on every line<DD><CODE>text</CODE> - flag if set to true will print out a text characters at the end of
          everyline<DD><CODE>data</CODE> - flag if set to true will print out raw HEX data on every line
<DT><B>Returns:</B><DD>multi-line hexdump of the entire memory region</DL>
</DD>
</DL>
<HR>

<A NAME="transferFrom(byte[])"><!-- --></A><H3>
transferFrom</H3>
<PRE>
protected int <B>transferFrom</B>(byte[]&nbsp;buffer)</PRE>
<DL>
<DD>Copies contents of byte array to memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - source buffer
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferFrom(byte[], int, int, int)"><!-- --></A><H3>
transferFrom</H3>
<PRE>
protected int <B>transferFrom</B>(byte[]&nbsp;buffer,
                           int&nbsp;srcOffset,
                           int&nbsp;length,
                           int&nbsp;dstOffset)</PRE>
<DL>
<DD>Copies contents of byte array to memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - source buffer<DD><CODE>srcOffset</CODE> - starting offset into the byte array<DD><CODE>length</CODE> - number of bytes to copy<DD><CODE>dstOffset</CODE> - starting offset into memory buffer
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferFrom(java.nio.ByteBuffer)"><!-- --></A><H3>
transferFrom</H3>
<PRE>
protected int <B>transferFrom</B>(java.nio.ByteBuffer&nbsp;src)</PRE>
<DL>
<DD>Copies data from memory from direct byte buffer to this memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - source buffer
<DT><B>Returns:</B><DD>actual number of bytes that was copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferFrom(java.nio.ByteBuffer, int)"><!-- --></A><H3>
transferFrom</H3>
<PRE>
protected int <B>transferFrom</B>(java.nio.ByteBuffer&nbsp;src,
                           int&nbsp;dstOffset)</PRE>
<DL>
<DD>Copies data from memory from direct byte buffer to this memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - source buffer<DD><CODE>dstOffset</CODE> - offset into our memory location
<DT><B>Returns:</B><DD>actual number of bytes that was copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferFromDirect(java.nio.ByteBuffer, int)"><!-- --></A><H3>
transferFromDirect</H3>
<PRE>
protected int <B>transferFromDirect</B>(java.nio.ByteBuffer&nbsp;src,
                                 int&nbsp;dstOffset)</PRE>
<DL>
<DD>Copies data from memory from direct byte buffer to this memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - source buffer<DD><CODE>dstOffset</CODE> - offset into our memory location
<DT><B>Returns:</B><DD>actual number of bytes that was copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferOwnership(org.jnetpcap.nio.JMemory)"><!-- --></A><H3>
transferOwnership</H3>
<PRE>
protected boolean <B>transferOwnership</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;memory)</PRE>
<DL>
<DD>A special method that allows one object to transfer ownership of a memory
 block. The supplied JMemory object must already be the owner of the memory
 block. This policy is strictly enforced. If the ownership transfer
 succeeds, this memory object will be responsible for freeing up memory
 block when this object is garbage collected or the user calls
 JMemory.cleanup() method. <h2>Warning!</h2> Care must be taken to only
 transfer ownership for simple memory allocations. If a complex memory
 allocation was used, one that sub allocates other memory blocks which are
 referenced from the original memory block, to avoid creating memory leaks.
 It is best practice to sub allocate other memory blocks using JMemory class
 which will properly manage that memory block and ensure that it will freed
 properly as well.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>memory</CODE> - memory block to transfer the ownership from
<DT><B>Returns:</B><DD>if tranfer succeeded true is returned, otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(byte[])"><!-- --></A><H3>
transferTo</H3>
<PRE>
protected int <B>transferTo</B>(byte[]&nbsp;buffer)</PRE>
<DL>
<DD>Copies data from memory to byte array.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - destination buffer starting offset in byte array
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(byte[], int, int, int)"><!-- --></A><H3>
transferTo</H3>
<PRE>
protected int <B>transferTo</B>(byte[]&nbsp;buffer,
                         int&nbsp;srcOffset,
                         int&nbsp;length,
                         int&nbsp;dstOffset)</PRE>
<DL>
<DD>Copies data from memory to byte array.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - destination buffer<DD><CODE>srcOffset</CODE> - starting offset in memory<DD><CODE>length</CODE> - number of bytes to copy<DD><CODE>dstOffset</CODE> - starting offset in byte array
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(java.nio.ByteBuffer)"><!-- --></A><H3>
transferTo</H3>
<PRE>
public int <B>transferTo</B>(java.nio.ByteBuffer&nbsp;dst)</PRE>
<DL>
<DD>Copies teh contents of this memory to buffer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - destination buffer
<DT><B>Returns:</B><DD>actual number of bytes that was copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(java.nio.ByteBuffer, int, int)"><!-- --></A><H3>
transferTo</H3>
<PRE>
public int <B>transferTo</B>(java.nio.ByteBuffer&nbsp;dst,
                      int&nbsp;srcOffset,
                      int&nbsp;length)</PRE>
<DL>
<DD>Copies teh contents of this memory to buffer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - destination buffer<DD><CODE>srcOffset</CODE> - offset in source<DD><CODE>length</CODE> - number of bytes to copy
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(org.jnetpcap.nio.JBuffer, int, int, int)"><!-- --></A><H3>
transferTo</H3>
<PRE>
public int <B>transferTo</B>(<A HREF="../../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;dst,
                      int&nbsp;srcOffset,
                      int&nbsp;length,
                      int&nbsp;dstOffset)</PRE>
<DL>
<DD>Transfers the contents of this memory to buffer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - destination buffer<DD><CODE>srcOffset</CODE> - offset in source<DD><CODE>length</CODE> - number of bytes to copy<DD><CODE>dstOffset</CODE> - offset in destination buffer
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(org.jnetpcap.nio.JMemory)"><!-- --></A><H3>
transferTo</H3>
<PRE>
protected int <B>transferTo</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;dst)</PRE>
<DL>
<DD>Copied the entire contents of this memory to destination memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - destination memory
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<HR>

<A NAME="transferTo(org.jnetpcap.nio.JMemory, int, int, int)"><!-- --></A><H3>
transferTo</H3>
<PRE>
protected int <B>transferTo</B>(<A HREF="../../../org/jnetpcap/nio/JMemory.html" title="class in org.jnetpcap.nio">JMemory</A>&nbsp;dst,
                         int&nbsp;srcOffset,
                         int&nbsp;length,
                         int&nbsp;dstOffset)</PRE>
<DL>
<DD>Copied the entire contents of this memory to destination memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dst</CODE> - destination memory<DD><CODE>srcOffset</CODE> - offset in source<DD><CODE>length</CODE> - number of bytes to copy<DD><CODE>dstOffset</CODE> - offset in destination buffer
<DT><B>Returns:</B><DD>number of bytes copied</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jnetpcap/nio/JFunction.html" title="class in org.jnetpcap.nio"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/nio/JMemory.Type.html" title="enum in org.jnetpcap.nio"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/nio/JMemory.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JMemory.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
