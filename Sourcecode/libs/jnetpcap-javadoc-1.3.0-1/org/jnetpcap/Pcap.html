<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_07) on Sat Apr 02 12:55:25 EDT 2011 -->
<TITLE>
Pcap
</TITLE>

<META NAME="date" CONTENT="2011-04-02">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Pcap";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/jnetpcap/JCaptureHeader.html" title="interface in org.jnetpcap"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/jnetpcap/PcapAddr.html" title="class in org.jnetpcap"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?org/jnetpcap/Pcap.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Pcap.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.jnetpcap</FONT>
<BR>
Class Pcap</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>org.jnetpcap.Pcap</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../org/jnetpcap/winpcap/WinPcap.html" title="class in org.jnetpcap.winpcap">WinPcap</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Pcap</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<P>
 This class is the main class peered with native <code>pcap_t</code> structure
 in libpcap and winpcap library impelementations. It provides a direct mapping
 of various library methods from Java.
 </P>
 <h2>Getting started</h2>
 <p>
 <code>Pcap</code> class provides several static methods which allow discovery
 of networking interfaces and then subsequently open up either
 <code>openLive</code>, <code>openDead</code> or <code>openOffline</code> pcap
 capture sessions. In all 3 cases a <code>Pcap</code> object is returned. The
 object is backed by a C <code>pcap_t</code> structure outside of java VM
 address space. Any non-static operations on the <code>Pcap</code> object, are
 translated using java JNI API into corresponding Libpcap C calls and the
 appropriate <code>pcap_t</code> C structure is supplied to complete the call.
 </p>
 <p>
 After aquiring a <code>Pcap</code> object from above mentioned static
 methods, you must call on <A HREF="../../org/jnetpcap/Pcap.html#close()"><CODE>close()</CODE></A> call to release any Libpcap
 resources and the backing C structure. The <code>Pcap</code> object does
 implicitly call the <A HREF="../../org/jnetpcap/Pcap.html#close()"><CODE>close()</CODE></A> method from its <A HREF="../../org/jnetpcap/Pcap.html#finalize()"><CODE>finalize()</CODE></A> method,
 but that will only happen when the <code>Pcap</code> is garabage collected.
 Its best practice to remember to always call on <A HREF="../../org/jnetpcap/Pcap.html#close()"><CODE>close()</CODE></A> when
 <code>Pcap</code> object and capture session is no longer needed.
 </p>
 <p>
 If <code>Pcap</code> object is closed and any of its non-static methods are
 called on, after the close, <CODE>IllegalStateException</CODE> will be thrown.
 </p>
 <h3>Getting a list of network interfaces from Pcap</h3> Lets get started with
 little example on how to inquire about available interfaces, ask the user to
 pick one of those interfaces for us, open it for capture, compile and install
 a capture filter and then start processing some packets captured as a result.
 This is all loosely based on examples you will find on tcpdump.org website
 but updated for jNetPCAP. As with libpcap, we first want to find out and get
 network interface names so we can tell jNetPCAP to open one or more for
 reading. So first we inquire about the list of interfaces on the system:
 
 <pre>
 StringBuilder errbuf = new StringBuilder();
 List&lt;PcapIf&gt; ifs = new ArrayList&lt;PcapIf&gt;(); // Will hold list of devices
 int statusCode = Pcap.findAllDevs(ifs, errbuf);
 if (statusCode != Pcap.OK) {
        System.out.println(&quot;Error occured: &quot; + errbuf.toString());
        return;
 }
 // We have a list of PcapIf devices to work with now.
 
 </pre>
 
 <p>
 <b>Note:</b> the return value from <A HREF="../../org/jnetpcap/Pcap.html#findAllDevs(java.util.List, java.lang.StringBuilder)"><CODE>findAllDevs(java.util.List<org.jnetpcap.PcapIf>, java.lang.StringBuilder)</CODE></A> is an integer result
 code, just like in the C counter part. The <code>ifs</code> list is filled in
 with all the network devices as found from the corresponding C structure
 <code>pcap_if</code> linked list returned from the C function call
 findAllDevs.
 </p>
 <p>
 Now that we have a list of devices, we we print out the list of them and ask
 the user to pick one to open for capture:
 
 <pre>
 for (int i = 0; i &lt; ifs.size(); i++) {
        System.out.println(&quot;#&quot; + i + &quot;: &quot; + ifs.get(i).getName());
 }
 
 String l = System.in.readline().trim();
 Integer i = Integer.valueOf(l);
 
 PcapIf netInterface = ifs.get(i);
 </pre>
 
 <h3>Opening a network interface for live capture</h3>
 Next we open up a live capture from the network interface using
 <A HREF="../../org/jnetpcap/Pcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><CODE>openLive(String, int, int, int, StringBuilder)</CODE></A>:
 
 <pre>
 int snalen = 2048; // Truncate packet at this size
 
 int promiscous = Pcap.MODE_PROMISCUOUS;
 
 int timeout = 60 * 1000; // In milliseconds
 
 Pcap pcap = Pcap.openLive(netInterface.getName(),
                snaplen,
                promiscous,
                timeout,
                errbuf);
 </pre>
 
 Last argument is a buffer that will hold an error string, if error occures.
 On error <code>openLive</code> will return null.
 <h3>Compiling and applying a filter to network interface</h3>
 Once we have an open interface for capture we can apply a filter to reduce
 amount of packets captured to something that is interesting to us:
 
 <pre>
 PcapBpfProgram filter = new PcapBpfProgram();
 String expression = &quot;port 23&quot;
 int optimize = 0; // 1 means true, 0 means false
 int netmask = 0;
 
 int r = pcap.compile(filter, expression, optimize, netmask);
 if (r != Pcap.OK) {
   System.out.println(&quot;Filter error: &quot; + pcap.getErr());
 }
 pcap.setFilter(filter);
 </pre>
 
 <p>
 If filter expression contained a syntax error, the return code will be -1 and
 exact error message can be retrieved using <A HREF="../../org/jnetpcap/Pcap.html#getErr()"><CODE>getErr()</CODE></A> method.
 </p>
 <p>
 <b>Note of caution:</b> the <code>PcapBpfProgram</code> at the top of the
 previous code section, can not be accessed until successfully filled in with
 values in the <code>pcap.compile</code> code. If you try and access any of
 its methods an <code>IllegalStateException</code> will be thrown. Only after
 a successful call to <code>compile</code> does the object become usable. The
 object is peered with C structure and until properly intialized, can not be
 accessed from java.
 </p>
 <h3>Dispatcher to receive packets as they arrive</h3> And lastly lets do
 something with the data.
 
 <pre>
 PcapHandler&lt;PrintStream&gt; handler = new PcapHandler&lt;PrintStream&gt;() {
 
        public void newPacket(PrintStream out,
                        int caplen,
                        int len,
                        int seconds,
                        int usecs,
                        ByteBuffer buffer) {
 
                out.println(&quot;Packet captured on: &quot; + new Date(seconds * 1000).toString());
        }
 };
 
 int cnt = 10; // Capture packet count
 PrintStream out = System.out; // Our custom object to send into the handler
 
 pcap.loop(cnt, handler, out); // Each packet will be dispatched to the handler
 
 pcap.close();
 </pre>
 
 <p>
 This sets up PCAP to capture 10 packets and notify our handler of each packet
 as each one is captured. Then after 10 packets the loop exits and we call
 pcap.close() to free up all the resources and we can safely throw away our
 pcap object. Also you may be curious why we pass System.out as userData to
 the loop handler. This is simply to demonstrate the typical usage for this
 kind of parameter. In our case we could easily pass a different PrintStream
 bound to lets say a network socket and our handler would produce output to
 it.
 </p>
 <p>
 Alternative way of capturing packets from any of the open pcap sessions is to
 use <A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.PcapPacketHandler, T)"><CODE>dispatch(int, PcapPacketHandler, Object)</CODE></A> method, which works
 very similarly to <A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.PcapPacketHandler, T)"><CODE>loop(int, PcapPacketHandler, Object)</CODE></A>. You can also
 use <A HREF="../../org/jnetpcap/Pcap.html#next(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><CODE>next(PcapHeader, JBuffer)</CODE></A> and
 <A HREF="../../org/jnetpcap/Pcap.html#nextEx(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><CODE>nextEx(PcapHeader, JBuffer)</CODE></A> methods which will deliver 1 packet at a
 time.
 </p>
 <h3>No packet data copies!</h3>
 <p>
 The packet data is delivered in a <code>java.nio.ByteBuffer</code>. The data
 is not copied into the buffer, but a direct byte buffer is allocated and
 wrapped around the packet data as returned from libpcap. No in memory copies
 are performed, so if the native operating system supports no-copy packet
 captures, the packet are delived to Java without copies. Only a single
 ByteBuffer object allocation is incured.
 </p>
 <h3>Omitted methods from standard lipcap API</h3> Certain deprecated methods
 from libpcap API have been omitted such as <code>lookupDev</code>,
 <code>lookupNet</code>. Also any methods that return <code>FILE *</code>
 since that is not appropriate for java environment. <h3>Multithreading issues
 </h3>
 <p>
 <code>Pcap</code> class does not provide any multithreading capabilities. As
 a pure wrapper for native <em>libpcap</em> library, <code>Pcap</code> does
 not provide any additional locking or multithreaded paradigms. The most
 suggesting method is the <A HREF="../../org/jnetpcap/Pcap.html#breakloop()"><CODE>breakloop()</CODE></A>, which can only be used from
 another thread. This is the extent of <code>Pcap</code>'s multithreading
 capabilities and threads have to be synchronized externally. Extrememe care
 must be taken, to ensure that no two methods are in use at the same time,
 with the exception of <code>breakloop()</code>. For example, calling on
 <A HREF="../../org/jnetpcap/Pcap.html#close()"><CODE>close()</CODE></A> while a loop is still in progress will cause
 <em>libpcap</em> libpcap to crash or coredump which will also crash the
 entire Java VM.
 </p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Mark Bednarczyk, Sly Technologies, Inc.</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#DEFAULT_PROMISC">DEFAULT_PROMISC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default capture promiscous mode to be used (default:.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#DEFAULT_SNAPLEN">DEFAULT_SNAPLEN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default capture SNAP len to be used (default: 65536).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#DEFAULT_TIMEOUT">DEFAULT_TIMEOUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default capture timeout (default: 0).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#DISPATCH_BUFFER_FULL">DISPATCH_BUFFER_FULL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value of packet count argument for <code>dispatch</code> method call which
 indicates that only as many packets should be returned as will fit in a
 single buffer , unless an error occured or <code>breakloop</code> call was
 used to interrupt the dispatcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#JNETPCAP_LIBRARY_NAME">JNETPCAP_LIBRARY_NAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name of the native library that wraps around libpcap and extensions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#LOOP_INFINATE">LOOP_INFINATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>The constant name is miss-spelled. You should use the correctly
             spelled constant LOOP_INFINITE</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#LOOP_INFINITE">LOOP_INFINITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Value of packet count argument for <code>loop</code> method call which
 indicates that the loop should never exit, unless an error occured or
 <code>breakloop</code> call was used to interrupt the dispatcher.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#LOOP_INTERRUPTED">LOOP_INTERRUPTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pcap status return code for <code>loop</code> and <code>dispatch</code>
 methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#MODE_BLOCKING">MODE_BLOCKING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'blocking' mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#MODE_NON_BLOCKING">MODE_NON_BLOCKING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'non-blocking' mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#MODE_NON_PROMISCUOUS">MODE_NON_PROMISCUOUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag used with <code>openLive</code> to specify that the interface should
 not be put into promisuous mode, but only if poassible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#MODE_PROMISCUOUS">MODE_PROMISCUOUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flag used with <code>openLive</code> to specify that the interface should
 be put into promisuous mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#NEXT_EX_EOF">NEXT_EX_EOF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exit code for <code>nextEx</code> method which indicates that pcap reached
 end of file while reading a 'savefile'.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#NEXT_EX_NOT_OK">NEXT_EX_NOT_OK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exit code for <code>nextEx</code> method which indicates failure of some
 kind.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#NEXT_EX_OK">NEXT_EX_OK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exit code for <code>nextEx</code> method which indicates success.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#NEXT_EX_TIMEDOUT">NEXT_EX_TIMEDOUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exit code for <code>nextEx</code> method which indicates timeout has
 expired before a packet was captured.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#NOT_OK">NOT_OK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pcap status return code for most of the methods defined here.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#OK">OK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pcap status return code for most of the methods defined here.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#Pcap()">Pcap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pcap object can only be created by calling one of the static.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#breakloop()">breakloop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 set a flag that will force pcap_dispatch() or pcap_loop() to return rather
 than looping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#checkIsActive()">checkIsActive</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current Pcap structure is active and open.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pcap_close() closes the files associated with p and deallocates resources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#compile(org.jnetpcap.PcapBpfProgram, java.lang.String, int, int)">compile</A></B>(<A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
        java.lang.String&nbsp;str,
        int&nbsp;optimize,
        int&nbsp;netmask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compile a packet filter, converting a high level filtering expression in to
 a progra that can be interpreted by the kernel-level filtering engine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#compileNoPcap(int, int, org.jnetpcap.PcapBpfProgram, java.lang.String, int, int)">compileNoPcap</A></B>(int&nbsp;snaplen,
              int&nbsp;dlt,
              <A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
              java.lang.String&nbsp;str,
              int&nbsp;optimize,
              int&nbsp;netmask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Compile a packet filter without the need of opening an adapter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#datalink()">datalink</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the link layer of an adapter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#datalinkNameToVal(java.lang.String)">datalinkNameToVal</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates a data link type name, which is a DLT_ name with the DLT_
 removed, to the corresponding data link type value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#datalinkValToDescription(int)">datalinkValToDescription</A></B>(int&nbsp;dlt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates a data link type value to a short description of that data link
 type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#datalinkValToName(int)">datalinkValToName</A></B>(int&nbsp;dlt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates a data link type value to the corresponding data link type name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.ByteBufferHandler, T)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, int, org.jnetpcap.packet.JPacketHandler, T)">dispatch</A></B>(int&nbsp;cnt,
         int&nbsp;id,
         <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, int, org.jnetpcap.packet.PcapPacketHandler, T)">dispatch</A></B>(int&nbsp;cnt,
         int&nbsp;id,
         <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.JBufferHandler, T)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.JPacketHandler, T)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.JPacketHandler, T, org.jnetpcap.packet.JScanner)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user,
         <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.PcapDumper)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/PcapDumper.html" title="class in org.jnetpcap">PcapDumper</A>&nbsp;dumper)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A specialized dispatch method that utilizes a fast native dumper without
 entering java environment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.PcapHandler, T)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>user of PcapHandler has been replaced with ByteBufferHandler</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.PcapPacketHandler, T)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>user of PcapHandler has been replaced with ByteBufferHandler</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dispatch(int, org.jnetpcap.packet.PcapPacketHandler, T, org.jnetpcap.packet.JScanner)">dispatch</A></B>(int&nbsp;cnt,
         <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
         T&nbsp;user,
         <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>user of PcapHandler has been replaced with ByteBufferHandler</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../org/jnetpcap/PcapDumper.html" title="class in org.jnetpcap">PcapDumper</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#dumpOpen(java.lang.String)">dumpOpen</A></B>(java.lang.String&nbsp;fname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a file to write packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#finalize()">finalize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleanup before we're GCed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#findAllDevs(java.util.List, java.lang.StringBuilder)">findAllDevs</A></B>(java.util.List&lt;<A HREF="../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
            java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pcap_findalldevs() constructs a list of network devices that can be opened
 with pcap_open_live().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#freeAllDevs(java.util.List, byte[])">freeAllDevs</A></B>(java.util.List&lt;<A HREF="../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
            byte[]&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use of byte[] errbuf is discouraged</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#freeAllDevs(java.util.List, java.lang.StringBuilder)">freeAllDevs</A></B>(java.util.List&lt;<A HREF="../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
            java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method does nothing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#freecode(org.jnetpcap.PcapBpfProgram)">freecode</A></B>(<A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This frees up the code structures, but does not released the peered base
 bpf_program peer structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#getErr()">getErr</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return the error text pertaining to the last pcap library error.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#getNonBlock(java.lang.StringBuilder)">getNonBlock</A></B>(java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pcap_getnonblock() returns the current ``non-blocking'' state of the
 capture descriptor; it always returns 0 on ``savefiles''.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#inject(byte[])">inject</A></B>(byte[]&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method allows to send a raw packet to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#inject(byte[], int, int)">inject</A></B>(byte[]&nbsp;buf,
       int&nbsp;offset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method allows to send a raw packet to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#inject(java.nio.ByteBuffer)">inject</A></B>(java.nio.ByteBuffer&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method allows to send a raw packet to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#inject(org.jnetpcap.nio.JBuffer, int, int)">inject</A></B>(<A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buf,
       int&nbsp;start,
       int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Private method to perform work.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#isInjectSupported()">isInjectSupported</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current platform has support for pcap_inject call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#isSendPacketSupported()">isSendPacketSupported</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current platform has support for pcap_sendpacket call.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#isSwapped()">isSwapped</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns true if the current savefile uses a different byte order than the
 current system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#libVersion()">libVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a pointer to a string giving information about the version of the
 libpcap library being used; note that it contains more information than
 just a version number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#lookupDev(java.lang.StringBuilder)">lookupDev</A></B>(java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a network device suitable for use with <code>openLive</code> and
 <code>lookupNet</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#lookupNet(java.lang.String, org.jnetpcap.nio.JNumber, org.jnetpcap.nio.JNumber, java.lang.StringBuilder)">lookupNet</A></B>(java.lang.String&nbsp;device,
          <A HREF="../../org/jnetpcap/nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</A>&nbsp;netp,
          <A HREF="../../org/jnetpcap/nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</A>&nbsp;maskp,
          java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines the network number and mask associated with the network device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#lookupNet(java.lang.String, org.jnetpcap.PcapInteger, org.jnetpcap.PcapInteger, java.lang.StringBuilder)">lookupNet</A></B>(java.lang.String&nbsp;device,
          <A HREF="../../org/jnetpcap/PcapInteger.html" title="class in org.jnetpcap">PcapInteger</A>&nbsp;netp,
          <A HREF="../../org/jnetpcap/PcapInteger.html" title="class in org.jnetpcap">PcapInteger</A>&nbsp;maskp,
          java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use of PcapInteger has been deprecated</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.ByteBufferHandler, T)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, int, org.jnetpcap.packet.JPacketHandler, T)">loop</A></B>(int&nbsp;cnt,
     int&nbsp;id,
     <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, int, org.jnetpcap.packet.PcapPacketHandler, T)">loop</A></B>(int&nbsp;cnt,
     int&nbsp;id,
     <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.JBufferHandler, T)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.JPacketHandler, T)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.JPacketHandler, T, org.jnetpcap.packet.JScanner)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user,
     <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.PcapDumper)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/PcapDumper.html" title="class in org.jnetpcap">PcapDumper</A>&nbsp;dumper)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A specialized loop method that utilizes a fast native dumper without
 entering java environment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.PcapHandler, T)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use of PcapHandler has been replaced with ByteBufferHandler</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.PcapPacketHandler, T)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#loop(int, org.jnetpcap.packet.PcapPacketHandler, T, org.jnetpcap.packet.JScanner)">loop</A></B>(int&nbsp;cnt,
     <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
     T&nbsp;user,
     <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collect a group of packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#majorVersion()">majorVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the major version number of the pcap library used to write the
 savefile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#minorVersion()">minorVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the minor version number of the pcap library used to write the
 savefile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#next(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)">next</A></B>(<A HREF="../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;pkt_header,
     <A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the next available packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.nio.ByteBuffer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#next(org.jnetpcap.PcapPktHdr)">next</A></B>(<A HREF="../../org/jnetpcap/PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</A>&nbsp;pkt_header)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use of PcapPktHdr has been replaced with PcapHeader</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#nextEx(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)">nextEx</A></B>(<A HREF="../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;pkt_header,
       <A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a packet from an interface or from an offline capture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#nextEx(org.jnetpcap.packet.PcapPacket)">nextEx</A></B>(<A HREF="../../org/jnetpcap/packet/PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</A>&nbsp;packet)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Read a packet from an interface or from an offline capture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#nextEx(org.jnetpcap.PcapPktHdr, org.jnetpcap.PcapPktBuffer)">nextEx</A></B>(<A HREF="../../org/jnetpcap/PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</A>&nbsp;pkt_header,
       <A HREF="../../org/jnetpcap/PcapPktBuffer.html" title="class in org.jnetpcap">PcapPktBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use PcapHeader and PcapPktBuffer has been deprecated</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#openDead(int, int)">openDead</A></B>(int&nbsp;linktype,
         int&nbsp;snaplen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a pcap_t structure without starting a capture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)">openLive</A></B>(java.lang.String&nbsp;device,
         int&nbsp;snaplen,
         int&nbsp;promisc,
         int&nbsp;timeout,
         java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Open a live capture associated with the specified network interface device.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#openOffline(java.lang.String, java.lang.StringBuilder)">openOffline</A></B>(java.lang.String&nbsp;fname,
            java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open a savefile in the tcpdump/libpcap format to read packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#sendPacket(byte[])">sendPacket</A></B>(byte[]&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method allows to send a raw packet to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#sendPacket(byte[], int, int)">sendPacket</A></B>(byte[]&nbsp;buf,
           int&nbsp;offset,
           int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method allows to send a raw packet to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#sendPacket(java.nio.ByteBuffer)">sendPacket</A></B>(java.nio.ByteBuffer&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method allows to send a raw packet to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#sendPacket(org.jnetpcap.nio.JBuffer)">sendPacket</A></B>(<A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method allows to send a raw packet to the network.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#setDatalink(int)">setDatalink</A></B>(int&nbsp;dlt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the current data link type of the pcap descriptor to the type specified
 by dlt.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#setFilter(org.jnetpcap.PcapBpfProgram)">setFilter</A></B>(<A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Associate a filter to a capture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#setNonBlock(int, java.lang.StringBuilder)">setNonBlock</A></B>(int&nbsp;nonBlock,
            java.lang.StringBuilder&nbsp;errbuf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pcap_setnonblock() puts a capture descriptor, opened with pcap_open_live(),
 into ``non-blocking'' mode, or takes it out of ``non-blocking'' mode,
 depending on whether the nonblock argument is non-zero or zero.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#snapshot()">snapshot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the dimension of the packet portion (in bytes) that is delivered to
 the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#stats(org.jnetpcap.PcapStat)">stats</A></B>(<A HREF="../../org/jnetpcap/PcapStat.html" title="class in org.jnetpcap">PcapStat</A>&nbsp;stats)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns statistics on the current capture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../org/jnetpcap/Pcap.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints libVersion that Pcap is based on.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_PROMISC"><!-- --></A><H3>
DEFAULT_PROMISC</H3>
<PRE>
public static final int <B>DEFAULT_PROMISC</B></PRE>
<DL>
<DD>Default capture promiscous mode to be used (default:.
 1)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.DEFAULT_PROMISC">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DEFAULT_SNAPLEN"><!-- --></A><H3>
DEFAULT_SNAPLEN</H3>
<PRE>
public static final int <B>DEFAULT_SNAPLEN</B></PRE>
<DL>
<DD>Default capture SNAP len to be used (default: 65536).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.DEFAULT_SNAPLEN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DEFAULT_TIMEOUT"><!-- --></A><H3>
DEFAULT_TIMEOUT</H3>
<PRE>
public static final int <B>DEFAULT_TIMEOUT</B></PRE>
<DL>
<DD>Default capture timeout (default: 0).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.DEFAULT_TIMEOUT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DISPATCH_BUFFER_FULL"><!-- --></A><H3>
DISPATCH_BUFFER_FULL</H3>
<PRE>
public static final int <B>DISPATCH_BUFFER_FULL</B></PRE>
<DL>
<DD>Value of packet count argument for <code>dispatch</code> method call which
 indicates that only as many packets should be returned as will fit in a
 single buffer , unless an error occured or <code>breakloop</code> call was
 used to interrupt the dispatcher. Note, that this constant is only
 appropriate value for <code>dispatch</code> method call. Loop method uses
 LOOP_INFINATE for something similar, but definately not identical to this
 option.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.DISPATCH_BUFFER_FULL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="JNETPCAP_LIBRARY_NAME"><!-- --></A><H3>
JNETPCAP_LIBRARY_NAME</H3>
<PRE>
public static final java.lang.String <B>JNETPCAP_LIBRARY_NAME</B></PRE>
<DL>
<DD>Name of the native library that wraps around libpcap and extensions.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.JNETPCAP_LIBRARY_NAME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LOOP_INFINATE"><!-- --></A><H3>
LOOP_INFINATE</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static final int <B>LOOP_INFINATE</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>The constant name is miss-spelled. You should use the correctly
             spelled constant LOOP_INFINITE</I><DD>Value of packet count argument for <code>loop</code> method call which
 indicates that the loop should never exit, unless an error occured or
 <code>breakloop</code> call was used to interrupt the dispatcher. Note,
 that this constant is not appropriate value for <code>dispatch</code>
 method call, which has a different meaning.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#LOOP_INFINITE"><CODE>LOOP_INFINITE</CODE></A>, 
<A HREF="../../constant-values.html#org.jnetpcap.Pcap.LOOP_INFINATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LOOP_INFINITE"><!-- --></A><H3>
LOOP_INFINITE</H3>
<PRE>
public static final int <B>LOOP_INFINITE</B></PRE>
<DL>
<DD>Value of packet count argument for <code>loop</code> method call which
 indicates that the loop should never exit, unless an error occured or
 <code>breakloop</code> call was used to interrupt the dispatcher. Note,
 that this constant is not appropriate value for <code>dispatch</code>
 method call, which has a different meaning.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.LOOP_INFINITE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LOOP_INTERRUPTED"><!-- --></A><H3>
LOOP_INTERRUPTED</H3>
<PRE>
public static final int <B>LOOP_INTERRUPTED</B></PRE>
<DL>
<DD>Pcap status return code for <code>loop</code> and <code>dispatch</code>
 methods. This status code indicates that the the dispatcher was interrupted
 by a call to <code>breakloop</code> call.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.LOOP_INTERRUPTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MODE_BLOCKING"><!-- --></A><H3>
MODE_BLOCKING</H3>
<PRE>
public static final int <B>MODE_BLOCKING</B></PRE>
<DL>
<DD>Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'blocking' mode. The flag can also
 be the return code from <code>getNonBlock</code>. The flag has no affect on
 'savefiles'.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.MODE_BLOCKING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MODE_NON_BLOCKING"><!-- --></A><H3>
MODE_NON_BLOCKING</H3>
<PRE>
public static final int <B>MODE_NON_BLOCKING</B></PRE>
<DL>
<DD>Flag which can be used with <code>setNonBlock</code> method to set the
 previously opened pcap descriptor into 'non-blocking' mode. The flag can
 also be the return code from <code>getNonBlock</code>. The flag has no
 affect on 'savefiles'.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.MODE_NON_BLOCKING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MODE_NON_PROMISCUOUS"><!-- --></A><H3>
MODE_NON_PROMISCUOUS</H3>
<PRE>
public static final int <B>MODE_NON_PROMISCUOUS</B></PRE>
<DL>
<DD>Flag used with <code>openLive</code> to specify that the interface should
 not be put into promisuous mode, but only if poassible. Note, the even
 though the flag is specified, the interface could still be opened in
 promiscous mode for other reasons, such as a different process had already
 put the interface into promiscuous mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.MODE_NON_PROMISCUOUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MODE_PROMISCUOUS"><!-- --></A><H3>
MODE_PROMISCUOUS</H3>
<PRE>
public static final int <B>MODE_PROMISCUOUS</B></PRE>
<DL>
<DD>Flag used with <code>openLive</code> to specify that the interface should
 be put into promisuous mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.MODE_PROMISCUOUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NEXT_EX_EOF"><!-- --></A><H3>
NEXT_EX_EOF</H3>
<PRE>
public static final int <B>NEXT_EX_EOF</B></PRE>
<DL>
<DD>Exit code for <code>nextEx</code> method which indicates that pcap reached
 end of file while reading a 'savefile'.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_EOF">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NEXT_EX_NOT_OK"><!-- --></A><H3>
NEXT_EX_NOT_OK</H3>
<PRE>
public static final int <B>NEXT_EX_NOT_OK</B></PRE>
<DL>
<DD>Exit code for <code>nextEx</code> method which indicates failure of some
 kind. Use <A HREF="../../org/jnetpcap/Pcap.html#getErr()"><CODE>getErr()</CODE></A> to retrieve the error message.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_NOT_OK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NEXT_EX_OK"><!-- --></A><H3>
NEXT_EX_OK</H3>
<PRE>
public static final int <B>NEXT_EX_OK</B></PRE>
<DL>
<DD>Exit code for <code>nextEx</code> method which indicates success.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_OK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NEXT_EX_TIMEDOUT"><!-- --></A><H3>
NEXT_EX_TIMEDOUT</H3>
<PRE>
public static final int <B>NEXT_EX_TIMEDOUT</B></PRE>
<DL>
<DD>Exit code for <code>nextEx</code> method which indicates timeout has
 expired before a packet was captured. The packet header and packet buffer
 do no point to any valid data.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.NEXT_EX_TIMEDOUT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NOT_OK"><!-- --></A><H3>
NOT_OK</H3>
<PRE>
public static final int <B>NOT_OK</B></PRE>
<DL>
<DD>Pcap status return code for most of the methods defined here. All methods
 that return an intenger as a status code, use this constants as meaning the
 call failed.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.NOT_OK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OK"><!-- --></A><H3>
OK</H3>
<PRE>
public static final int <B>OK</B></PRE>
<DL>
<DD>Pcap status return code for most of the methods defined here. All methods
 that return an intenger as a status code, use this constants as meaning the
 call succeeded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#org.jnetpcap.Pcap.OK">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Pcap()"><!-- --></A><H3>
Pcap</H3>
<PRE>
public <B>Pcap</B>()</PRE>
<DL>
<DD>Pcap object can only be created by calling one of the static.
 
 <A HREF="../../org/jnetpcap/Pcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><CODE>openLive(java.lang.String, int, int, int, java.lang.StringBuilder)</CODE></A> methods.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="compileNoPcap(int, int, org.jnetpcap.PcapBpfProgram, java.lang.String, int, int)"><!-- --></A><H3>
compileNoPcap</H3>
<PRE>
public static int <B>compileNoPcap</B>(int&nbsp;snaplen,
                                int&nbsp;dlt,
                                <A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
                                java.lang.String&nbsp;str,
                                int&nbsp;optimize,
                                int&nbsp;netmask)</PRE>
<DL>
<DD><p>
 Compile a packet filter without the need of opening an adapter. This
 function converts an high level filtering expression (see Filtering
 expression syntax) in a program that can be interpreted by the kernel-level
 filtering engine.
 </p>
 <p>
 pcap_compile_nopcap() is similar to pcap_compile() except that instead of
 passing a pcap structure, one passes the snaplen and linktype explicitly.
 It is intended to be used for compiling filters for direct BPF usage,
 without necessarily having called pcap_open(). (pcap_compile_nopcap() is a
 wrapper around pcap_open_dead(), pcap_compile(), and pcap_close(); the
 latter three routines can be used directly in order to get the error text
 for a compilation error.)
 </p>
 <p>
 Look at the Filtering expression syntax section for details on the str
 parameter.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>snaplen</CODE> - generate code to truncate packets to this length upon a match<DD><CODE>dlt</CODE> - the first header type within the packet, or data link type of the
          interface<DD><CODE>program</CODE> - initially empty, but after the method call will contain the
          compiled BPF program<DD><CODE>str</CODE> - a string containing the textual expression to be compiled<DD><CODE>optimize</CODE> - 1 means to do optimizations, any other value means no<DD><CODE>netmask</CODE> - netmask needed to determine the broadcast address
<DT><B>Returns:</B><DD>a return of -1 indicates an error; the error text is unavailable;
         lastly, the compiled program is stored and therefore returned in
         the formal parameter <code>program</code></DL>
</DD>
</DL>
<HR>

<A NAME="datalinkNameToVal(java.lang.String)"><!-- --></A><H3>
datalinkNameToVal</H3>
<PRE>
public static int <B>datalinkNameToVal</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Translates a data link type name, which is a DLT_ name with the DLT_
 removed, to the corresponding data link type value. The translation is
 case-insensitive. -1 is returned on failure.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - data link type name
<DT><B>Returns:</B><DD>data link type value or -1 on failure</DL>
</DD>
</DL>
<HR>

<A NAME="datalinkValToDescription(int)"><!-- --></A><H3>
datalinkValToDescription</H3>
<PRE>
public static java.lang.String <B>datalinkValToDescription</B>(int&nbsp;dlt)</PRE>
<DL>
<DD>Translates a data link type value to a short description of that data link
 type. NULL is returned on failure.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dlt</CODE> - data link type value
<DT><B>Returns:</B><DD>short description of that data link type, NULL is returned on
         failure</DL>
</DD>
</DL>
<HR>

<A NAME="datalinkValToName(int)"><!-- --></A><H3>
datalinkValToName</H3>
<PRE>
public static java.lang.String <B>datalinkValToName</B>(int&nbsp;dlt)</PRE>
<DL>
<DD>Translates a data link type value to the corresponding data link type name.
 NULL is returned on failure.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dlt</CODE> - data link type value
<DT><B>Returns:</B><DD>data link type value to the corresponding data link type name, NULL
         is returned on failure</DL>
</DD>
</DL>
<HR>

<A NAME="findAllDevs(java.util.List, java.lang.StringBuilder)"><!-- --></A><H3>
findAllDevs</H3>
<PRE>
public static int <B>findAllDevs</B>(java.util.List&lt;<A HREF="../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
                              java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>pcap_findalldevs() constructs a list of network devices that can be opened
 with pcap_open_live(). (Note that there may be network devices that cannot
 be opened with pcap_open_live() by the process calling pcap_findalldevs(),
 because, for example, that process might not have sufficient privileges to
 open them for capturing; if so, those devices will not appear on the list.)
 alldevs is set to point to the first element of the list; each element of
 the list is of type pcap_if_t, and has the following members:
 <ul>
 <li>next if not NULL, a pointer to the next element in the list; NULL for
 the last element of the list
 <li>name a pointer to a string giving a name for the device to pass to
 pcap_open_live()
 <li>description if not NULL, a pointer to a string giving a human-readable
 description of the device
 <li>addresses a pointer to the first element of a list of addresses for the
 interface
 <li>flags interface flags: PCAP_IF_LOOPBACK set if the interface is a
 loopback interface
 </ul>
 Each element of the list of addresses is of type pcap_addr_t, and has the
 following members:
 <ul>
 <li>next if not NULL, a pointer to the next element in the list; NULL for
 the last element of the list
 <li>addr a pointer to a struct sockaddr containing an address
 <li>netmask if not NULL, a pointer to a struct sockaddr that contains the
 netmask corresponding to the address pointed to by addr
 <li>broadaddr if not NULL, a pointer to a struct sockaddr that contains the
 broadcast address corresponding to the address pointed to by addr; may be
 null if the interface doesn't support broadcasts
 <li>dstaddr if not NULL, a pointer to a struct sockaddr that contains the
 destination address corresponding to the address pointed to by addr; may be
 null if the interface isn't a point-to-point interface
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alldevs</CODE> - the list is filled in with <code>PcapIf</code> interface objects;
          the list must not be immutable<DD><CODE>errbuf</CODE> - error buffer containing error message as a string on failure
<DT><B>Returns:</B><DD>-1 is returned on failure, in which case errbuf is filled in with
         an appropriate error message; 0 is returned on success<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="freeAllDevs(java.util.List, byte[])"><!-- --></A><H3>
freeAllDevs</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static void <B>freeAllDevs</B>(java.util.List&lt;<A HREF="../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
                                          byte[]&nbsp;errbuf)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use of byte[] errbuf is discouraged</I>
<P>
<DD>This method does nothing. jNetPcap implementation frees up the device list
 immediately after its copied into Java objects in java space. The source
 structures are immediately released. pcap_freealldevs() is used to free a
 list allocated by pcap_findalldevs().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alldevs</CODE> - is set to point to the first element of the list; each element of
          the list is of type PcapIf<DD><CODE>errbuf</CODE> - error buffer containing error message as a string on failure<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#freeAllDevs(java.util.List, java.lang.StringBuilder)"><CODE>freeAllDevs(List, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="freeAllDevs(java.util.List, java.lang.StringBuilder)"><!-- --></A><H3>
freeAllDevs</H3>
<PRE>
public static void <B>freeAllDevs</B>(java.util.List&lt;<A HREF="../../org/jnetpcap/PcapIf.html" title="class in org.jnetpcap">PcapIf</A>&gt;&nbsp;alldevs,
                               java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>This method does nothing. jNetPcap implementation frees up the device list
 immediately after its copied into Java objects in java space. The source
 structures are immediately released. pcap_freealldevs() is used to free a
 list allocated by pcap_findalldevs().
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alldevs</CODE> - is set to point to the first element of the list; each element of
          the list is of type PcapIf<DD><CODE>errbuf</CODE> - error buffer containing error message as a string on failure<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="freecode(org.jnetpcap.PcapBpfProgram)"><!-- --></A><H3>
freecode</H3>
<PRE>
public static void <B>freecode</B>(<A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program)</PRE>
<DL>
<DD>This frees up the code structures, but does not released the peered base
 bpf_program peer structure. Only the allocated storage to hold the code is
 freedup. The peered bpf_program structure is only freed when the program
 object is garbage collected.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - program to free up the backend resources for</DL>
</DD>
</DL>
<HR>

<A NAME="isInjectSupported()"><!-- --></A><H3>
isInjectSupported</H3>
<PRE>
public static boolean <B>isInjectSupported</B>()</PRE>
<DL>
<DD>Checks if the current platform has support for pcap_inject call. The
 support is libpcap version and platform dependent.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true means <A HREF="../../org/jnetpcap/Pcap.html#inject(byte[])"><CODE>inject(byte[])</CODE></A> is supported, otherwise not<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#inject(byte[])"><CODE>inject(byte[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isSendPacketSupported()"><!-- --></A><H3>
isSendPacketSupported</H3>
<PRE>
public static boolean <B>isSendPacketSupported</B>()</PRE>
<DL>
<DD>Checks if the current platform has support for pcap_sendpacket call. The
 support is libpcap version and platform dependent.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true means <A HREF="../../org/jnetpcap/Pcap.html#sendPacket(byte[])"><CODE>sendPacket(byte[])</CODE></A> is supported, otherwise not<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#sendPacket(byte[])"><CODE>sendPacket(byte[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="libVersion()"><!-- --></A><H3>
libVersion</H3>
<PRE>
public static java.lang.String <B>libVersion</B>()</PRE>
<DL>
<DD>Returns a pointer to a string giving information about the version of the
 libpcap library being used; note that it contains more information than
 just a version number.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>version of the libpcap library being used</DL>
</DD>
</DL>
<HR>

<A NAME="lookupDev(java.lang.StringBuilder)"><!-- --></A><H3>
lookupDev</H3>
<PRE>
public static java.lang.String <B>lookupDev</B>(java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>Returns a network device suitable for use with <code>openLive</code> and
 <code>lookupNet</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>errbuf</CODE> - if there is an error, errbuf is filled with appropriate message
<DT><B>Returns:</B><DD>name of the device or null on error</DL>
</DD>
</DL>
<HR>

<A NAME="lookupNet(java.lang.String, org.jnetpcap.nio.JNumber, org.jnetpcap.nio.JNumber, java.lang.StringBuilder)"><!-- --></A><H3>
lookupNet</H3>
<PRE>
public static int <B>lookupNet</B>(java.lang.String&nbsp;device,
                            <A HREF="../../org/jnetpcap/nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</A>&nbsp;netp,
                            <A HREF="../../org/jnetpcap/nio/JNumber.html" title="class in org.jnetpcap.nio">JNumber</A>&nbsp;maskp,
                            java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>Determines the network number and mask associated with the network device.
 Both netp and maskp are integer object references whos value is set from
 within the call. This is the way that pcap natively passes back these two
 values.
 <p>
 <b>Note:</b> this method is deprecated in pcap as it can not be used to
 pass back information about IP v6 addresses.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - device to do the lookup on<DD><CODE>netp</CODE> - object which will contain the value of network address<DD><CODE>maskp</CODE> - object which will contain the value of network netmask<DD><CODE>errbuf</CODE> - any error messages if return value is -1
<DT><B>Returns:</B><DD>0 on success otherwise -1 on error</DL>
</DD>
</DL>
<HR>

<A NAME="lookupNet(java.lang.String, org.jnetpcap.PcapInteger, org.jnetpcap.PcapInteger, java.lang.StringBuilder)"><!-- --></A><H3>
lookupNet</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public static int <B>lookupNet</B>(java.lang.String&nbsp;device,
                                       <A HREF="../../org/jnetpcap/PcapInteger.html" title="class in org.jnetpcap">PcapInteger</A>&nbsp;netp,
                                       <A HREF="../../org/jnetpcap/PcapInteger.html" title="class in org.jnetpcap">PcapInteger</A>&nbsp;maskp,
                                       java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use of PcapInteger has been deprecated</I>
<P>
<DD>Determines the network number and mask associated with the network device.
 Both netp and maskp are integer object references whos value is set from
 within the call. This is the way that pcap natively passes back these two
 values.
 <p>
 <b>Note:</b> this method is deprecated in pcap as it can not be used to
 pass back information about IP v6 addresses.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - device to do the lookup on<DD><CODE>netp</CODE> - object which will contain the value of network address<DD><CODE>maskp</CODE> - object which will contain the value of network netmask<DD><CODE>errbuf</CODE> - any error messages if return value is -1
<DT><B>Returns:</B><DD>0 on success otherwise -1 on error<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#lookupNet(java.lang.String, org.jnetpcap.nio.JNumber, org.jnetpcap.nio.JNumber, java.lang.StringBuilder)"><CODE>lookupNet(String, JNumber, JNumber, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="openDead(int, int)"><!-- --></A><H3>
openDead</H3>
<PRE>
public static <A HREF="../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A> <B>openDead</B>(int&nbsp;linktype,
                            int&nbsp;snaplen)</PRE>
<DL>
<DD>Create a pcap_t structure without starting a capture. pcap_open_dead() is
 used for creating a pcap_t structure to use when calling the other
 functions in libpcap. It is typically used when just using libpcap for
 compiling BPF code.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>linktype</CODE> - pcap DLT link type integer value<DD><CODE>snaplen</CODE> - filters generated using the pcap structure will truncate captured
          packets to this length
<DT><B>Returns:</B><DD>Pcap structure that can only be used to generate filter code and
         none of its other capture methods should be called or null if error
         occured</DL>
</DD>
</DL>
<HR>

<A NAME="openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><!-- --></A><H3>
openLive</H3>
<PRE>
public static <A HREF="../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A> <B>openLive</B>(java.lang.String&nbsp;device,
                            int&nbsp;snaplen,
                            int&nbsp;promisc,
                            int&nbsp;timeout,
                            java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD><p>
 Open a live capture associated with the specified network interface device.
 pcap_open_live() is used to obtain a packet capture descriptor to look at
 packets on the network. device is a string that specifies the network
 device to open; on Linux systems with 2.2 or later kernels, a device
 argument of "any" or NULL can be used to capture packets from all
 interfaces. snaplen specifies the maximum number of bytes to capture. If
 this value is less than the size of a packet that is captured, only the
 first snaplen bytes of that packet will be captured and provided as packet
 data. A value of 65535 should be sufficient, on most if not all networks,
 to capture all the data available from the packet. promisc specifies if the
 interface is to be put into promiscuous mode. (Note that even if this
 parameter is false, the interface could well be in promiscuous mode for
 some other reason.)
 </p>
 <p>
 For now, this doesn't work on the "any" device; if an argument of "any" or
 NULL is supplied, the promisc flag is ignored. to_ms specifies the read
 timeout in milliseconds. The read timeout is used to arrange that the read
 not necessarily return immediately when a packet is seen, but that it wait
 for some amount of time to allow more packets to arrive and to read
 multiple packets from the OS kernel in one operation. Not all platforms
 support a read timeout; on platforms that don't, the read timeout is
 ignored. A zero value for to_ms, on platforms that support a read timeout,
 will cause a read to wait forever to allow enough packets to arrive, with
 no timeout. errbuf is used to return error or warning text. It will be set
 to error text when pcap_open_live() fails and returns NULL. errbuf may also
 be set to warning text when pcap_open_live() succeds; to detect this case
 the caller should store a zero-length string in errbuf before calling
 pcap_open_live() and display the warning to the user if errbuf is no longer
 a zero-length string.
 </p>
 <p>
 <b>Special note about <code>snaplen</code> argument.</b> The behaviour of
 this argument may be suprizing to some. The <code>argument</code> is only
 applied when there is a filter set using <code>setFilter</code> method
 after the <code>openLive</code> call. Otherwise snaplen, even non zero is
 ignored. This is the behavior of all BSD systems utilizing BPF and WinPcap.
 This may change in the future, but that is the current behavior. (For more
 detailed explanation and discussion please see jNetPcap website and its
 FAQs.)
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>device</CODE> - buffer containing a C, '\0' terminated string with the the name of
          the device<DD><CODE>snaplen</CODE> - amount of data to capture per packet; (see special note in doc
          comments about when this argument is ignored even when non-zero)<DD><CODE>promisc</CODE> - 1 means open in promiscious mode, a 0 means non-propmiscous<DD><CODE>timeout</CODE> - timeout in ms<DD><CODE>errbuf</CODE> - a buffer that will contain any error messages if the call to open
          failed
<DT><B>Returns:</B><DD>a raw structure the data of <code>pcap_t</code> C structure as
         returned by native libpcap call to open<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="openOffline(java.lang.String, java.lang.StringBuilder)"><!-- --></A><H3>
openOffline</H3>
<PRE>
public static <A HREF="../../org/jnetpcap/Pcap.html" title="class in org.jnetpcap">Pcap</A> <B>openOffline</B>(java.lang.String&nbsp;fname,
                               java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>Open a savefile in the tcpdump/libpcap format to read packets.
 pcap_open_offline() is called to open a "savefile" for reading. fname
 specifies the name of the file to open. The file has the same format as
 those used by tcpdump(1) and tcpslice(1). The name "-" in a synonym for
 stdin. Alternatively, you may call pcap_fopen_offline() to read dumped data
 from an existing open stream fp. Note that on Windows, that stream should
 be opened in binary mode. errbuf is used to return error text and is only
 set when pcap_open_offline() or pcap_fopen_offline() fails and returns
 NULL.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fname</CODE> - filename of the pcap file<DD><CODE>errbuf</CODE> - any error messages in UTC8 encoding
<DT><B>Returns:</B><DD>Pcap structure or null if error occured<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="breakloop()"><!-- --></A><H3>
breakloop</H3>
<PRE>
public void <B>breakloop</B>()</PRE>
<DL>
<DD><p>
 set a flag that will force pcap_dispatch() or pcap_loop() to return rather
 than looping. They will return the number of packets that have been
 processed so far, or -2 if no packets have been processed so far. This
 routine is safe to use inside a signal handler on UNIX or a console control
 handler on Windows, as it merely sets a flag that is checked within the
 loop. The flag is checked in loops reading packets from the OS - a signal
 by itself will not necessarily terminate those loops - as well as in loops
 processing a set of packets returned by the OS. Note that if you are
 catching signals on UNIX systems that support restarting system calls after
 a signal, and calling pcap_breakloop() in the signal handler, you must
 specify, when catching those signals, that system calls should NOT be
 restarted by that signal. Otherwise, if the signal interrupted a call
 reading packets in a live capture, when your signal handler returns after
 calling pcap_breakloop(), the call will be restarted, and the loop will not
 terminate until more packets arrive and the call completes.
 </p>
 <p>
 Note: pcap_next() will, on some platforms, loop reading packets from the
 OS; that loop will not necessarily be terminated by a signal, so
 pcap_breakloop() should be used to terminate packet processing even if
 pcap_next() is being used. pcap_breakloop() does not guarantee that no
 further packets will be processed by pcap_dispatch() or pcap_loop() after
 it is called; at most one more packet might be processed. If -2 is returned
 from pcap_dispatch() or pcap_loop(), the flag is cleared, so a subsequent
 call will resume reading packets. If a positive number is returned, the
 flag is not cleared, so a subsequent call will return -2 and clear the
 flag.
 </p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkIsActive()"><!-- --></A><H3>
checkIsActive</H3>
<PRE>
protected void <B>checkIsActive</B>()
                      throws <A HREF="../../org/jnetpcap/PcapClosedException.html" title="class in org.jnetpcap">PcapClosedException</A></PRE>
<DL>
<DD>Checks if the current Pcap structure is active and open. It automatically
 throws an exception when its closed, but will not crash the VM. All dynamic
 non-native method in Pcap and any subclassed extensions should always make
 this call before attempting to do anything with pcap. The call makes sure
 that the pcap_t structure is still allocated and assigned to this object.
 If Pcap has been closed, no dynamic methods should be allowed to do
 anything. Native methods already perform this check. Static methods do not
 rely on pcap_t structure, since they are static, so they can not do this
 check.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../org/jnetpcap/PcapClosedException.html" title="class in org.jnetpcap">PcapClosedException</A></CODE> - if pcap_t structure has been deallocated, another words if
           Pcap.close has already been called.</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public void <B>close</B>()</PRE>
<DL>
<DD>pcap_close() closes the files associated with p and deallocates resources.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="compile(org.jnetpcap.PcapBpfProgram, java.lang.String, int, int)"><!-- --></A><H3>
compile</H3>
<PRE>
public int <B>compile</B>(<A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program,
                   java.lang.String&nbsp;str,
                   int&nbsp;optimize,
                   int&nbsp;netmask)</PRE>
<DL>
<DD>Compile a packet filter, converting a high level filtering expression in to
 a progra that can be interpreted by the kernel-level filtering engine.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - initially empty, but after the method call will contain the
          compiled BPF program<DD><CODE>str</CODE> - a string containing the textual expression to be compiled<DD><CODE>optimize</CODE> - 1 means to do optimizations, any other value means no<DD><CODE>netmask</CODE> - netmask needed to determine the broadcast address
<DT><B>Returns:</B><DD>A return of -1 indicates an error in which case <A HREF="../../org/jnetpcap/Pcap.html#getErr()"><CODE>getErr()</CODE></A>
         may be used to display the error text.</DL>
</DD>
</DL>
<HR>

<A NAME="datalink()"><!-- --></A><H3>
datalink</H3>
<PRE>
public int <B>datalink</B>()</PRE>
<DL>
<DD>Returns the link layer of an adapter.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>PCAP link layer number</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,org.jnetpcap.ByteBufferHandler,java.lang.Object)"><!-- --></A><A NAME="dispatch(int, org.jnetpcap.ByteBufferHandler, T)"><!-- --></A><H3>
dispatch</H3>
<PRE>
public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                        <A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</A>&lt;T&gt;&nbsp;handler,
                        T&nbsp;user)</PRE>
<DL>
<DD><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)"><!-- --></A><A NAME="dispatch(int, int, org.jnetpcap.packet.JPacketHandler, T)"><!-- --></A><H3>
dispatch</H3>
<PRE>
public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                        int&nbsp;id,
                        <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
                        T&nbsp;user)</PRE>
<DL>
<DD><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>id</CODE> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object
<DT><B>Returns:</B><DD>number of packet captured</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)"><!-- --></A><A NAME="dispatch(int, int, org.jnetpcap.packet.PcapPacketHandler, T)"><!-- --></A><H3>
dispatch</H3>
<PRE>
public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                        int&nbsp;id,
                        <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
                        T&nbsp;user)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>id</CODE> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object
<DT><B>Returns:</B><DD>number of packet captured</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,org.jnetpcap.JBufferHandler,java.lang.Object)"><!-- --></A><A NAME="dispatch(int, org.jnetpcap.JBufferHandler, T)"><!-- --></A><H3>
dispatch</H3>
<PRE>
public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                        <A HREF="../../org/jnetpcap/JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</A>&lt;T&gt;&nbsp;handler,
                        T&nbsp;user)</PRE>
<DL>
<DD><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)"><!-- --></A><A NAME="dispatch(int, org.jnetpcap.packet.JPacketHandler, T)"><!-- --></A><H3>
dispatch</H3>
<PRE>
public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                        <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
                        T&nbsp;user)</PRE>
<DL>
<DD><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object
<DT><B>Returns:</B><DD>number of packet captured</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)"><!-- --></A><A NAME="dispatch(int, org.jnetpcap.packet.JPacketHandler, T, org.jnetpcap.packet.JScanner)"><!-- --></A><H3>
dispatch</H3>
<PRE>
public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                        <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
                        T&nbsp;user,
                        <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</PRE>
<DL>
<DD><p>
 Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 </p>
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object<DD><CODE>scanner</CODE> - user supplied custom packet scanner
<DT><B>Returns:</B><DD>number of packet captured</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int, org.jnetpcap.PcapDumper)"><!-- --></A><H3>
dispatch</H3>
<PRE>
public int <B>dispatch</B>(int&nbsp;cnt,
                    <A HREF="../../org/jnetpcap/PcapDumper.html" title="class in org.jnetpcap">PcapDumper</A>&nbsp;dumper)</PRE>
<DL>
<DD>A specialized dispatch method that utilizes a fast native dumper without
 entering java environment. A custom native pcap handler is provided that
 dumps all incoming packets to the dumper without any processing.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>dumper</CODE> - open pcap dumper to dump all packets to
<DT><B>Returns:</B><DD>number of packets processed</DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,org.jnetpcap.PcapHandler,java.lang.Object)"><!-- --></A><A NAME="dispatch(int, org.jnetpcap.PcapHandler, T)"><!-- --></A><H3>
dispatch</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                                   <A HREF="../../org/jnetpcap/PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</A>&lt;T&gt;&nbsp;handler,
                                   T&nbsp;user)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>user of PcapHandler has been replaced with ByteBufferHandler</I>
<P>
<DD>Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap"><CODE>ByteBufferHandler</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)"><!-- --></A><A NAME="dispatch(int, org.jnetpcap.packet.PcapPacketHandler, T)"><!-- --></A><H3>
dispatch</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                                   <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
                                   T&nbsp;user)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>user of PcapHandler has been replaced with ByteBufferHandler</I>
<P>
<DD>Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap"><CODE>ByteBufferHandler</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dispatch(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)"><!-- --></A><A NAME="dispatch(int, org.jnetpcap.packet.PcapPacketHandler, T, org.jnetpcap.packet.JScanner)"><!-- --></A><H3>
dispatch</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public &lt;T&gt; int <B>dispatch</B>(int&nbsp;cnt,
                                   <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
                                   T&nbsp;user,
                                   <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>user of PcapHandler has been replaced with ByteBufferHandler</I>
<P>
<DD>Collect a group of packets. pcap_dispatch() is used to collect and process
 packets. cnt specifies the maximum number of packets to process before
 returning. This is not a minimum number; when reading a live capture, only
 one bufferful of packets is read at a time, so fewer than cnt packets may
 be processed. A cnt of -1 processes all the packets received in one buffer
 when reading a live capture, or all the packets in the file when reading a
 ``savefile''. callback specifies a routine to be called with three
 arguments: a u_char pointer which is passed in from pcap_dispatch(), a
 const struct pcap_pkthdr pointer, and a const u_char pointer to the first
 caplen (as given in the struct pcap_pkthdr a pointer to which is passed to
 the callback routine) bytes of data from the packet (which won't
 necessarily be the entire packet; to capture the entire packet, you will
 have to provide a value for snaplen in your call to pcap_open_live() that
 is sufficiently large to get all of the packet's data - a value of 65535
 should be sufficient on most if not all networks).
 <p>
 The number of packets read is returned. 0 is returned if no packets were
 read from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read) or if no more
 packets are available in a ``savefile.'' A return of -1 indicates an error
 in which case pcap_perror() or pcap_geterr() may be used to display the
 error text. A return of -2 indicates that the loop terminated due to a call
 to pcap_breakloop() before any packets were processed. If your application
 uses pcap_breakloop(), make sure that you explicitly check for -1 and -2,
 rather than just checking for a return value < 0.
 </p>
 <p>
 Note: when reading a live capture, pcap_dispatch() will not necessarily
 return when the read times out; on some platforms, the read timeout isn't
 supported, and, on other platforms, the timer doesn't start until at least
 one packet arrives. This means that the read timeout should NOT be used in,
 for example, an interactive application, to allow the packet capture loop
 to ``poll'' for user input periodically, as there's no guarantee that
 pcap_dispatch() will return after the timeout expires.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object<DD><CODE>scanner</CODE> - a custom user quick-scanner for parsing headers within the packet
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap"><CODE>ByteBufferHandler</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dumpOpen(java.lang.String)"><!-- --></A><H3>
dumpOpen</H3>
<PRE>
public <A HREF="../../org/jnetpcap/PcapDumper.html" title="class in org.jnetpcap">PcapDumper</A> <B>dumpOpen</B>(java.lang.String&nbsp;fname)</PRE>
<DL>
<DD>Open a file to write packets. The <code>dumpOpen</code> method is called to
 open a "savefile" for writing. The name '-' is a synonym for stdout.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fname</CODE> - specifies the name of the file to open; currently the libpcap
          option to open stdout by using "-" as a string, is not supported
          by jNetPcap
<DT><B>Returns:</B><DD>a dumper object or null on error; use <code>getErr</code> method to
         retrieve the error message</DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A><H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL>
<DD>Cleanup before we're GCed. Will close connection to any open interface.
 Does nothing if connection already closed.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>finalize</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getErr()"><!-- --></A><H3>
getErr</H3>
<PRE>
public java.lang.String <B>getErr</B>()</PRE>
<DL>
<DD>return the error text pertaining to the last pcap library error.
 <p>
 Note: the pointer Return will no longer point to a valid error message
 string after the pcap_t passed to it is closed; you must use or copy the
 string before closing the pcap_t.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the error text pertaining to the last pcap library error</DL>
</DD>
</DL>
<HR>

<A NAME="getNonBlock(java.lang.StringBuilder)"><!-- --></A><H3>
getNonBlock</H3>
<PRE>
public int <B>getNonBlock</B>(java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>pcap_getnonblock() returns the current ``non-blocking'' state of the
 capture descriptor; it always returns 0 on ``savefiles''. If there is an
 error, -1 is returned and errbuf is filled in with an appropriate error
 message.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>errbuf</CODE> - error buffer where error message will be stored on error
<DT><B>Returns:</B><DD>if there is an error, -1 is returned and errbuf is filled in with
         an appropriate error message<DT><B>Since:</B></DT>
  <DD>1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#setNonBlock(int, java.lang.StringBuilder)"><CODE>setNonBlock(int, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="inject(byte[])"><!-- --></A><H3>
inject</H3>
<PRE>
public int <B>inject</B>(byte[]&nbsp;buf)</PRE>
<DL>
<DD>This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - contains the data of the packet to send (including the various
          protocol headers)
<DT><B>Returns:</B><DD>0 number of bytes written otherwise -1 on failure</DL>
</DD>
</DL>
<HR>

<A NAME="inject(byte[], int, int)"><!-- --></A><H3>
inject</H3>
<PRE>
public int <B>inject</B>(byte[]&nbsp;buf,
                  int&nbsp;offset,
                  int&nbsp;length)</PRE>
<DL>
<DD>This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - contains the data of the packet to send (including the various
          protocol headers)<DD><CODE>offset</CODE> - offset of the first index into the byte array<DD><CODE>length</CODE> - amount of data to write from the offset
<DT><B>Returns:</B><DD>0 number of bytes written otherwise -1 on failure</DL>
</DD>
</DL>
<HR>

<A NAME="inject(java.nio.ByteBuffer)"><!-- --></A><H3>
inject</H3>
<PRE>
public int <B>inject</B>(java.nio.ByteBuffer&nbsp;buf)</PRE>
<DL>
<DD>This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - contains the data of the packet to send (including the various
          protocol headers); the buffer should be a direct buffer; array
          based buffers will be copied into a direct buffer
<DT><B>Returns:</B><DD>0 number of bytes written otherwise -1 on failure</DL>
</DD>
</DL>
<HR>

<A NAME="inject(org.jnetpcap.nio.JBuffer, int, int)"><!-- --></A><H3>
inject</H3>
<PRE>
public int <B>inject</B>(<A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buf,
                  int&nbsp;start,
                  int&nbsp;len)</PRE>
<DL>
<DD>Private method to perform work. The arguments are guarranteed to work with
 buf since we're using a delagate method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - buffer contains raw data to send<DD><CODE>start</CODE> - offset into the buffer<DD><CODE>len</CODE> - number of bytes to send
<DT><B>Returns:</B><DD>0 number of bytes written otherwise -1 on failure<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isSwapped()"><!-- --></A><H3>
isSwapped</H3>
<PRE>
public int <B>isSwapped</B>()</PRE>
<DL>
<DD>returns true if the current savefile uses a different byte order than the
 current system.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>0 is false, non-zero is true</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,org.jnetpcap.ByteBufferHandler,java.lang.Object)"><!-- --></A><A NAME="loop(int, org.jnetpcap.ByteBufferHandler, T)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    <A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap">ByteBufferHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)"><!-- --></A><A NAME="loop(int, int, org.jnetpcap.packet.JPacketHandler, T)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    int&nbsp;id,
                    <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>id</CODE> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)"><!-- --></A><A NAME="loop(int, int, org.jnetpcap.packet.PcapPacketHandler, T)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    int&nbsp;id,
                    <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
 <p>
 This method derrives the numerical protocol ID for the data link header
 automatically using <code>Pcap.datalink()</code> value returned.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>id</CODE> - numerical protocol ID found in JProtocol.ID constant and in
          JRegistery<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,org.jnetpcap.JBufferHandler,java.lang.Object)"><!-- --></A><A NAME="loop(int, org.jnetpcap.JBufferHandler, T)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    <A HREF="../../org/jnetpcap/JBufferHandler.html" title="interface in org.jnetpcap">JBufferHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object)"><!-- --></A><A NAME="loop(int, org.jnetpcap.packet.JPacketHandler, T)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,org.jnetpcap.packet.JPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)"><!-- --></A><A NAME="loop(int, org.jnetpcap.packet.JPacketHandler, T, org.jnetpcap.packet.JScanner)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    <A HREF="../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user,
                    <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object<DD><CODE>scanner</CODE> - user supplied custom packet scanner
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int, org.jnetpcap.PcapDumper)"><!-- --></A><H3>
loop</H3>
<PRE>
public int <B>loop</B>(int&nbsp;cnt,
                <A HREF="../../org/jnetpcap/PcapDumper.html" title="class in org.jnetpcap">PcapDumper</A>&nbsp;dumper)</PRE>
<DL>
<DD>A specialized loop method that utilizes a fast native dumper without
 entering java environment. A custom native pcap handler is provided that
 dumps all incoming packets to the dumper without any processing.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>dumper</CODE> - open pcap dumper to dump all packets to
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,org.jnetpcap.PcapHandler,java.lang.Object)"><!-- --></A><A NAME="loop(int, org.jnetpcap.PcapHandler, T)"><!-- --></A><H3>
loop</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                               <A HREF="../../org/jnetpcap/PcapHandler.html" title="interface in org.jnetpcap">PcapHandler</A>&lt;T&gt;&nbsp;handler,
                               T&nbsp;user)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use of PcapHandler has been replaced with ByteBufferHandler</I>
<P>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - handler's user object type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to read<DD><CODE>handler</CODE> - called when packet arrives for each packet<DD><CODE>user</CODE> - opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/ByteBufferHandler.html" title="interface in org.jnetpcap"><CODE>ByteBufferHandler</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object)"><!-- --></A><A NAME="loop(int, org.jnetpcap.packet.PcapPacketHandler, T)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</DL>
</DD>
</DL>
<HR>

<A NAME="loop(int,org.jnetpcap.packet.PcapPacketHandler,java.lang.Object,org.jnetpcap.packet.JScanner)"><!-- --></A><A NAME="loop(int, org.jnetpcap.packet.PcapPacketHandler, T, org.jnetpcap.packet.JScanner)"><!-- --></A><H3>
loop</H3>
<PRE>
public &lt;T&gt; int <B>loop</B>(int&nbsp;cnt,
                    <A HREF="../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler</A>&lt;T&gt;&nbsp;handler,
                    T&nbsp;user,
                    <A HREF="../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A>&nbsp;scanner)</PRE>
<DL>
<DD>Collect a group of packets. pcap_loop() is similar to pcap_dispatch()
 except it keeps reading packets until cnt packets are processed or an error
 occurs. It does not return when live read timeouts occur. Rather,
 specifying a non-zero read timeout to pcap_open_live() and then calling
 pcap_dispatch() allows the reception and processing of any packets that
 arrive when the timeout occurs. A negative cnt causes pcap_loop() to loop
 forever (or at least until an error occurs). -1 is returned on an error; 0
 is returned if cnt is exhausted; -2 is returned if the loop terminated due
 to a call to pcap_breakloop() before any packets were processed. If your
 application uses pcap_breakloop(), make sure that you explicitly check for
 -1 and -2, rather than just checking for a return value < 0.
 <p>
 This implementation of disptach method performs a scan of the packet buffer
 as it is delivered by libpcap. The scanned information is recorded in
 native scanner structures which are then peered with a JPacket object
 instance. The receiver of the dispatched packets
 <code>JPacketHandler.nextPacket</code> receives fully decoded packets.
 </p>
 <p>
 This method provides its own thread-local <code>JScanner</code> and default
 shared <code>JPacket</code> instance. The same packet is dispatched to the
 user with the state of the packet being changed between each dispatch. If
 the user requires the packet state to persist longer than a single
 iteration of the dispatcher, the delivered packets state must either be
 peered with a different packet (only copied by reference) or the entire
 contents and state must be copied to a new packet (a deep copy). The
 shallow copy by reference persists longer, but not indefinately. It persist
 as long as libpcap internal large capture buffer doesn't wrap around. The
 same goes for JScanner's internal scan buffer, it too persists until the
 state information exhausts the buffer and the buffer is wrapped around to
 the begining as well overriding any information in the scan buffer. If
 there are still any packets that reference that scan buffer information,
 once that information is overriden by the latest scan, the original scan
 information is gone forever and will guarrantee that any old packets still
 pointing at the scan buffer will have incorrect infromation.
 </p>
 <p>
 <code>JPacket</code> class provides methods which allow deep copy of the
 packet data and state to be made to a new permanent location. This
 mechanism works in conjuction of <code>JMemoryPool</code> class which
 facilitates native memory management on large scale. Once the packet data
 and state are deep copied to new memory location, that packet can stay
 permanently in memory. The memory will only be released when all the java
 object references to that memory are garbage collected. The memory is
 deallocated automatically.
 </p>
<P>
<DD><DL>
<DT><B>Type Parameters:</B><DD><CODE>T</CODE> - user data type<DT><B>Parameters:</B><DD><CODE>cnt</CODE> - number of packets to process<DD><CODE>handler</CODE> - user supplied packet handler<DD><CODE>user</CODE> - a custom opaque user object<DD><CODE>scanner</CODE> - user supplied custom packet scanner
<DT><B>Returns:</B><DD>0 on success, -1 on error and -2 if breakloop was used interrupt
         the captue</DL>
</DD>
</DL>
<HR>

<A NAME="majorVersion()"><!-- --></A><H3>
majorVersion</H3>
<PRE>
public int <B>majorVersion</B>()</PRE>
<DL>
<DD>Return the major version number of the pcap library used to write the
 savefile.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>return the major version number of the pcap library used to write
         the savefile</DL>
</DD>
</DL>
<HR>

<A NAME="minorVersion()"><!-- --></A><H3>
minorVersion</H3>
<PRE>
public int <B>minorVersion</B>()</PRE>
<DL>
<DD>Return the minor version number of the pcap library used to write the
 savefile.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>return the minor version number of the pcap library used to write
         the savefile</DL>
</DD>
</DL>
<HR>

<A NAME="next(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><!-- --></A><H3>
next</H3>
<PRE>
public <A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A> <B>next</B>(<A HREF="../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;pkt_header,
                    <A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD>Return the next available packet. pcap_next() reads the next packet (by
 calling pcap_dispatch() with a cnt of 1) and returns a u_char pointer to
 the data in that packet. (The pcap_pkthdr struct for that packet is not
 supplied.) NULL is returned if an error occured, or if no packets were read
 from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read), or if no more
 packets are available in a ``savefile.'' Unfortunately, there is no way to
 determine whether an error occured or not.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pkt_header</CODE> - a packet header that will be initialized to corresponding C
          structure captured values<DD><CODE>buffer</CODE> - a buffer that will be peered with returned buffer from libpcap
<DT><B>Returns:</B><DD>buffer containing packet data or null if error occured<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="next(org.jnetpcap.PcapPktHdr)"><!-- --></A><H3>
next</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public java.nio.ByteBuffer <B>next</B>(<A HREF="../../org/jnetpcap/PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</A>&nbsp;pkt_header)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use of PcapPktHdr has been replaced with PcapHeader</I>
<P>
<DD>Return the next available packet. pcap_next() reads the next packet (by
 calling pcap_dispatch() with a cnt of 1) and returns a u_char pointer to
 the data in that packet. (The pcap_pkthdr struct for that packet is not
 supplied.) NULL is returned if an error occured, or if no packets were read
 from a live capture (if, for example, they were discarded because they
 didn't pass the packet filter, or if, on platforms that support a read
 timeout that starts before any packets arrive, the timeout expires before
 any packets arrive, or if the file descriptor for the capture device is in
 non-blocking mode and no packets were available to be read), or if no more
 packets are available in a ``savefile.'' Unfortunately, there is no way to
 determine whether an error occured or not.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pkt_header</CODE> - a packet header that will be initialized to corresponding C
          structure captured values
<DT><B>Returns:</B><DD>buffer containing packet data or null if error occured<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap"><CODE>PcapHeader</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="nextEx(org.jnetpcap.PcapHeader, org.jnetpcap.nio.JBuffer)"><!-- --></A><H3>
nextEx</H3>
<PRE>
public int <B>nextEx</B>(<A HREF="../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap">PcapHeader</A>&nbsp;pkt_header,
                  <A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD>Read a packet from an interface or from an offline capture. This function
 is used to retrieve the next available packet, bypassing the callback
 method traditionally provided by libpcap. pcap_next_ex fills the pkt_header
 and pkt_data parameters (see pcap_handler()) with the pointers to the
 header and to the data of the next captured packet. </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pkt_header</CODE> - a packet header that will be initialized to corresponding C
          structure captured values<DD><CODE>buffer</CODE> - buffer containing packet data or null if error occured
<DT><B>Returns:</B><DD>the status code
         <ul>
         <li>1 if the packet has been read without problems
         <li>0 if the timeout set with pcap_open_live() has elapsed. In this
         case pkt_header and pkt_data don't point to a valid packet
         <li>-1 if an error occurred
         <li>-2 if EOF was reached reading from an offline capture
         </ul><DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextEx(org.jnetpcap.packet.PcapPacket)"><!-- --></A><H3>
nextEx</H3>
<PRE>
public int <B>nextEx</B>(<A HREF="../../org/jnetpcap/packet/PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</A>&nbsp;packet)</PRE>
<DL>
<DD><p>
 Read a packet from an interface or from an offline capture. This function
 is used to retrieve the next available packet, bypassing the callback
 method traditionally provided by libpcap. The packet that is supplied as
 formal parameter, is used to peer, not copy, with the header and buffer of
 the next packet returned from libpcap. The supplied packet's PcapHeader is
 used to peer with the libpcap provided header and the packet object itself
 is used to peer with the libpcap provided packet buffer.
 </p>
 <p>
 The packet contents will point at libpcap buffer space which is not
 permanent. If packet contents are to be referenced on more permanent basis,
 it will be neccessary to copy the contents to a new packet. Here is a short
 example:
 
 <pre>
 Pcap pcap = ...; // From somewhere
 PcapPacket packet = new PcapPacket(JMemory.POINTER);
 
 while (nextEx(packet) == Pcap.NEXT_EX_OK) {
   PcapPacket copy = new PcapPacket(packet); // Make the copy and new obj
 }
 </pre>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>packet</CODE> - packet that will be peered with the next libpcap returned packet
<DT><B>Returns:</B><DD>the status code
         <ul>
         <li>1 if the packet has been read without problems <li>0 if the
         timeout set with pcap_open_live() has elapsed. In this case
         pkt_header and pkt_data don't point to a valid packet <li>-1 if an
         error occurred <li>-2 if EOF was reached reading from an offline
         capture
         </ul><DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextEx(org.jnetpcap.PcapPktHdr, org.jnetpcap.PcapPktBuffer)"><!-- --></A><H3>
nextEx</H3>
<PRE>
<FONT SIZE="-1">@Deprecated
</FONT>public int <B>nextEx</B>(<A HREF="../../org/jnetpcap/PcapPktHdr.html" title="class in org.jnetpcap">PcapPktHdr</A>&nbsp;pkt_header,
                             <A HREF="../../org/jnetpcap/PcapPktBuffer.html" title="class in org.jnetpcap">PcapPktBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use PcapHeader and PcapPktBuffer has been deprecated</I>
<P>
<DD>Read a packet from an interface or from an offline capture. This function
 is used to retrieve the next available packet, bypassing the callback
 method traditionally provided by libpcap. pcap_next_ex fills the pkt_header
 and pkt_data parameters (see pcap_handler()) with the pointers to the
 header and to the data of the next captured packet. </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pkt_header</CODE> - a packet header that will be initialized to corresponding C
          structure captured values<DD><CODE>buffer</CODE> - buffer containing packet data or null if error occured
<DT><B>Returns:</B><DD>the status code
         <ul>
         <li>1 if the packet has been read without problems
         <li>0 if the timeout set with pcap_open_live() has elapsed. In this
         case pkt_header and pkt_data don't point to a valid packet
         <li>-1 if an error occurred
         <li>-2 if EOF was reached reading from an offline capture
         </ul><DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/PcapHeader.html" title="class in org.jnetpcap"><CODE>PcapHeader</CODE></A>, 
<A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio"><CODE>JBuffer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sendPacket(byte[])"><!-- --></A><H3>
sendPacket</H3>
<PRE>
public int <B>sendPacket</B>(byte[]&nbsp;buf)</PRE>
<DL>
<DD>This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - contains the data of the packet to send (including the various
          protocol headers)
<DT><B>Returns:</B><DD>0 on success and -1 on failure</DL>
</DD>
</DL>
<HR>

<A NAME="sendPacket(byte[], int, int)"><!-- --></A><H3>
sendPacket</H3>
<PRE>
public int <B>sendPacket</B>(byte[]&nbsp;buf,
                      int&nbsp;offset,
                      int&nbsp;length)</PRE>
<DL>
<DD>This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - contains the data of the packet to send (including the various
          protocol headers)<DD><CODE>offset</CODE> - offset of the first index into the byte array<DD><CODE>length</CODE> - amount of data to write from the offset
<DT><B>Returns:</B><DD>0 on success and -1 on failure</DL>
</DD>
</DL>
<HR>

<A NAME="sendPacket(java.nio.ByteBuffer)"><!-- --></A><H3>
sendPacket</H3>
<PRE>
public int <B>sendPacket</B>(java.nio.ByteBuffer&nbsp;buf)</PRE>
<DL>
<DD>This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - contains the data of the packet to send (including the various
          protocol headers); the buffer should be a direct buffer; array
          based buffers will be copied into a direct buffer
<DT><B>Returns:</B><DD>0 on success and -1 on failure</DL>
</DD>
</DL>
<HR>

<A NAME="sendPacket(org.jnetpcap.nio.JBuffer)"><!-- --></A><H3>
sendPacket</H3>
<PRE>
public int <B>sendPacket</B>(<A HREF="../../org/jnetpcap/nio/JBuffer.html" title="class in org.jnetpcap.nio">JBuffer</A>&nbsp;buf)</PRE>
<DL>
<DD>This method allows to send a raw packet to the network. The MAC CRC doesn't
 need to be included, because it is transparently calculated and added by
 the network interface driver. The data will be taken from the supplied
 buffer where the start of the packet is buffer's current position()
 property and end its limit() properties.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf</CODE> - contains the data of the packet to send (including the various
          protocol headers); the buffer should be a direct buffer; array
          based buffers will be copied into a direct buffer
<DT><B>Returns:</B><DD>0 on success and -1 on failure<DT><B>Since:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDatalink(int)"><!-- --></A><H3>
setDatalink</H3>
<PRE>
public int <B>setDatalink</B>(int&nbsp;dlt)</PRE>
<DL>
<DD>Set the current data link type of the pcap descriptor to the type specified
 by dlt.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dlt</CODE> - new dlt
<DT><B>Returns:</B><DD>-1 is returned on failure</DL>
</DD>
</DL>
<HR>

<A NAME="setFilter(org.jnetpcap.PcapBpfProgram)"><!-- --></A><H3>
setFilter</H3>
<PRE>
public int <B>setFilter</B>(<A HREF="../../org/jnetpcap/PcapBpfProgram.html" title="class in org.jnetpcap">PcapBpfProgram</A>&nbsp;program)</PRE>
<DL>
<DD>Associate a filter to a capture. pcap_setfilter() is used to specify a
 filter program. fp is a pointer to a bpf_program struct, usually the result
 of a call to pcap_compile(). -1 is returned on failure, in which case
 pcap_geterr() may be used to display the error text; 0 is returned on
 success.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - the program
<DT><B>Returns:</B><DD>-1 is returned on failure, in which case pcap_geterr() may be used
         to display the error text; 0 is returned on success</DL>
</DD>
</DL>
<HR>

<A NAME="setNonBlock(int, java.lang.StringBuilder)"><!-- --></A><H3>
setNonBlock</H3>
<PRE>
public int <B>setNonBlock</B>(int&nbsp;nonBlock,
                       java.lang.StringBuilder&nbsp;errbuf)</PRE>
<DL>
<DD>pcap_setnonblock() puts a capture descriptor, opened with pcap_open_live(),
 into ``non-blocking'' mode, or takes it out of ``non-blocking'' mode,
 depending on whether the nonblock argument is non-zero or zero. It has no
 effect on ``savefiles''. If there is an error, -1 is returned and errbuf is
 filled in with an appropriate error message; otherwise, 0 is returned. In
 ``non-blocking'' mode, an attempt to read from the capture descriptor with
 pcap_dispatch() will, if no packets are currently available to be read,
 return 0 immediately rather than blocking waiting for packets to arrive.
 pcap_loop() and pcap_next() will not work in ``non-blocking'' mode.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nonBlock</CODE> - a non negative value means to set in non blocking mode<DD><CODE>errbuf</CODE> - error buffer where error message will be stored on error
<DT><B>Returns:</B><DD>if there is an error, -1 is returned and errbuf is filled in with
         an appropriate error message<DT><B>Since:</B></DT>
  <DD>1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#getNonBlock(java.lang.StringBuilder)"><CODE>getNonBlock(StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="snapshot()"><!-- --></A><H3>
snapshot</H3>
<PRE>
public int <B>snapshot</B>()</PRE>
<DL>
<DD>Return the dimension of the packet portion (in bytes) that is delivered to
 the application. pcap_snapshot() returns the snapshot length specified when
 pcap_open_live was called.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the snapshot length specified when pcap_open_live was called<DT><B>See Also:</B><DD><A HREF="../../org/jnetpcap/Pcap.html#openLive(java.lang.String, int, int, int, java.lang.StringBuilder)"><CODE>openLive(String, int, int, int, StringBuilder)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stats(org.jnetpcap.PcapStat)"><!-- --></A><H3>
stats</H3>
<PRE>
public int <B>stats</B>(<A HREF="../../org/jnetpcap/PcapStat.html" title="class in org.jnetpcap">PcapStat</A>&nbsp;stats)</PRE>
<DL>
<DD>Returns statistics on the current capture. The method fills in the PcapStat
 structure. The values represent packet statistics from the start of the run
 to the time of the call.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stats</CODE> - PcapStat object to fill in
<DT><B>Returns:</B><DD>-1 if underlying packet capture doesn't support packet statistics
         or if there is an error; use <code>getErr</code> to retrieve the
         error message</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Prints libVersion that Pcap is based on.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>libpcap version in use by this pcap object</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../org/jnetpcap/JCaptureHeader.html" title="interface in org.jnetpcap"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../org/jnetpcap/PcapAddr.html" title="class in org.jnetpcap"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?org/jnetpcap/Pcap.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Pcap.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
