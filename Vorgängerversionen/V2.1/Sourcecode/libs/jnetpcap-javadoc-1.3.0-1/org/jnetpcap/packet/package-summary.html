<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_07) on Sat Apr 02 12:55:35 EDT 2011 -->
<TITLE>
org.jnetpcap.packet
</TITLE>

<META NAME="date" CONTENT="2011-04-02">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="org.jnetpcap.packet";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jnetpcap/nio/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/packet/annotate/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/packet/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
Package org.jnetpcap.packet
</H2>
Packet decoding framework.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JBinding.html" title="interface in org.jnetpcap.packet">JBinding</A></B></TD>
<TD>A bindinding between two protocol headers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JCompoundHeader.html" title="interface in org.jnetpcap.packet">JCompoundHeader&lt;B extends JHeader&gt;</A></B></TD>
<TD>The Interface JCompoundHeader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JDependency.html" title="interface in org.jnetpcap.packet">JDependency</A></B></TD>
<TD>Lists binding's protocol dependencies.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeaderAccessor.html" title="interface in org.jnetpcap.packet">JHeaderAccessor</A></B></TD>
<TD>Accessor to get a structured header from underlying buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeaderChecksum.html" title="interface in org.jnetpcap.packet">JHeaderChecksum</A></B></TD>
<TD>Interface implemented by protocol headers that maintain a header and possibly
 payload checksums.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeaderType.html" title="interface in org.jnetpcap.packet">JHeaderType</A></B></TD>
<TD>The Interface JHeaderType.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JPacketHandler.html" title="interface in org.jnetpcap.packet">JPacketHandler&lt;T&gt;</A></B></TD>
<TD>A dispatchable packet hadler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JPayloadAccessor.html" title="interface in org.jnetpcap.packet">JPayloadAccessor</A></B></TD>
<TD>Interface which provides access to payload portion of the packet data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/PcapPacketHandler.html" title="interface in org.jnetpcap.packet">PcapPacketHandler&lt;T&gt;</A></B></TD>
<TD>The Interface PcapPacketHandler.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/AbstractBinding.html" title="class in org.jnetpcap.packet">AbstractBinding&lt;H extends JHeader&gt;</A></B></TD>
<TD>The Class AbstractBinding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/AbstractMessageHeader.html" title="class in org.jnetpcap.packet">AbstractMessageHeader</A></B></TD>
<TD>The Class AbstractMessageHeader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JBinding.DefaultJBinding.html" title="class in org.jnetpcap.packet">JBinding.DefaultJBinding</A></B></TD>
<TD>An abstract adaptor that provides a default implementation for a binding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JFlow.html" title="class in org.jnetpcap.packet">JFlow</A></B></TD>
<TD>The Class JFlow.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JFlowKey.html" title="class in org.jnetpcap.packet">JFlowKey</A></B></TD>
<TD>A unique key that identifies a flow of related packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JFlowMap.html" title="class in org.jnetpcap.packet">JFlowMap</A></B></TD>
<TD>The Class JFlowMap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeader.html" title="class in org.jnetpcap.packet">JHeader</A></B></TD>
<TD>A base class for all protocol header definitions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeader.State.html" title="class in org.jnetpcap.packet">JHeader.State</A></B></TD>
<TD>This class is peered state of a header a native state structure</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeaderMap.html" title="class in org.jnetpcap.packet">JHeaderMap&lt;B extends JHeader&gt;</A></B></TD>
<TD>The Class JHeaderMap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeaderPool.html" title="class in org.jnetpcap.packet">JHeaderPool</A></B></TD>
<TD>A thread local pool of instances of headers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JHeaderScanner.html" title="class in org.jnetpcap.packet">JHeaderScanner</A></B></TD>
<TD>A header scanner, there is one per header, that is able to scan raw memory
 buffer and determine the length of the header and the next header ID after
 examining the current header's structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JMappedHeader.html" title="class in org.jnetpcap.packet">JMappedHeader</A></B></TD>
<TD>The Class JMappedHeader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JMemoryPacket.html" title="class in org.jnetpcap.packet">JMemoryPacket</A></B></TD>
<TD>A heap based packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JMemoryPacket.JMemoryHeader.html" title="class in org.jnetpcap.packet">JMemoryPacket.JMemoryHeader</A></B></TD>
<TD>A capture header that stores information about the creation of the packet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JPacket.html" title="class in org.jnetpcap.packet">JPacket</A></B></TD>
<TD>A native packet buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JPacket.State.html" title="class in org.jnetpcap.packet">JPacket.State</A></B></TD>
<TD>Class maintains the decoded packet state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JRegistry.html" title="class in org.jnetpcap.packet">JRegistry</A></B></TD>
<TD>A registry of protocols, their classes, runtime IDs and bindings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JScan.html" title="class in org.jnetpcap.packet">JScan</A></B></TD>
<TD>A inprogress working scan structure.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JScanner.html" title="class in org.jnetpcap.packet">JScanner</A></B></TD>
<TD>JMemory with struct scanner_t, binding_t, packet_t and header_t structures.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JScannerReference.html" title="class in org.jnetpcap.packet">JScannerReference</A></B></TD>
<TD>The Class JScannerReference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/JSubHeader.html" title="class in org.jnetpcap.packet">JSubHeader&lt;T extends JHeader&gt;</A></B></TD>
<TD>The Class JSubHeader.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/Payload.html" title="class in org.jnetpcap.packet">Payload</A></B></TD>
<TD>Builtin header type that is a catch all for all unmatch data within a packet
 buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/PcapPacket.html" title="class in org.jnetpcap.packet">PcapPacket</A></B></TD>
<TD>A pcap packet.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Enum Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/AbstractMessageHeader.MessageType.html" title="enum in org.jnetpcap.packet">AbstractMessageHeader.MessageType</A></B></TD>
<TD>The Enum MessageType.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Exception Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/PeeringException.html" title="class in org.jnetpcap.packet">PeeringException</A></B></TD>
<TD>The Class PeeringException.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/RegistryException.html" title="class in org.jnetpcap.packet">RegistryException</A></B></TD>
<TD>The Class RegistryException.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/RegistryHeaderErrors.html" title="class in org.jnetpcap.packet">RegistryHeaderErrors</A></B></TD>
<TD>The Class RegistryHeaderErrors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/RegistryRuntimeException.html" title="class in org.jnetpcap.packet">RegistryRuntimeException</A></B></TD>
<TD>The Class RegistryRuntimeException.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../org/jnetpcap/packet/UnregisteredHeaderException.html" title="class in org.jnetpcap.packet">UnregisteredHeaderException</A></B></TD>
<TD>Thrown when a lookup on a header in JRegistry fails.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package org.jnetpcap.packet Description
</H2>

<P>
Packet decoding framework. Packet buffers are scanned and decoded.

<h2>Overview</h2>
The package adds new
<code>loop</code>
and
<code>dispatch</code>
methods that deliver decoded packets to the registered handler. The
class JPacket allows the programmer to check for existance of certain
protocol headers within the packet's data buffer. The programmer can use
a header to then access any of the fields and logic for that protocol.
<p>Here is an example of what a JPacketHandler might look like:
<pre>
JPacketHandler<String> handler = new JPacketHandler<String>() {
  private Ethernet eth = new Ethernet();
  private Ip4 ip = new Ip4();
  
  public void nextPacket(JPacket packet, String user) {
    if (packet.hasHeader(Ethernet.ID)) {
      eth = packet.getHeader(eth);
      byte[] dstMac = eth.destination();
      byte[] srcMac = eth.source();
      int type = eth.type();
      // Do something
    }
    
    /*
     * For convenience there is a hasHeader method that takes a header instance
     * and combines hasHeader with getHeader methods if the header exists.
     */
    if (packet.hasHeader(ip)) {      
      int flags = ip.flags();
      int offset = ip.offset();
      byte[] srcIp = ip.source();
      byte[] dstIp = ip.destination();
      int protocol = ip.protocol();
    }
    
    // Or can simply print out the contents of the packet
    System.out.println(packet.toString());
  }
}
</pre>
The example demonstates a
<code>JPacketHandler</code>
implementation, which gets passed into
<code>loop/dispatch</code>
methods and receives packets. The handler's
<code>nextPacket</code>
method receives a fully decoded packet. The information about which
headers exist, where in the buffer and how long they are is recorded in
native structures which
<code>JPacket, JPacket.State, JHeader, JHeader.State</code>
classes access. The method
<code>JPacket.hasHeader</code>
is a simply bitwise operation on an unsigned integer that is very
efficient and fast.
</p>
<p>The typical steps for working with the packet objects is first to
check if the header the user is insterested in exists in the packet, has
been found by the packet scanner, and then request that user supplied
header instance is peered with the native structures that describe that
header.(Peering means that the physical address of the native structure
is recorded somewhere in the java class beeing peered and afterwards
that class uses that pointer to access and retrieve data from the
physical native structure or buffer.) 
<h2><a
        href="https://sourceforge.net/tracker2/?func=detail&aid=2292402&group_id=164277&atid=831086">Feature
#2292402:</a> A packet decoding framework</h2>
This feature "packet decoding framework" extends basic jNetPcap
capabilities of capturing a network packet or reading it from an offline
file, then delivering that packet as a raw byte buffer to a PcapHandler
which is a user provided callback object. The packet framework adds
additional capabilities where the raw byte buffer is decoded into an
array of headers contained within a PcapPacket or more commonly a super
class JPacket.
<p>The framework provides additional <code>Pcap.loop and
Pcap.dispatch</code> methods which allow the user to supply a <code>JPacketHandler</code>,
as opposed to <code>PcapHandler</code>, which delivers a decoded <code>JPacket</code>
object to the user's callback method <code>JPacketHandler.nextPacket(JPacket
packet, Object user)</code></p>
<p><code>JPacket</code> class is the main interface to the decoded
packet information, specifically; which protocol headers exist in the
packet, found by scanning the raw byte buffer, and detailed information
on those headers. The user can query a <code>JPacket</code> using
methods <code>JPacket.hasHeader(int id)</code>, <code>JPacket.getHeader(T
header):&lt;T extends JHeader&gt; T</code> and <code>JPacket.getCaptureHeader()</code>
which returns the capture information such as timestamp and wirele
(length of the packet as seen on the network wire.)</p>
<p>There are also numerous support and other implementation classes
such as
<ul>
        <li>JRegistry - is a singleton class where all the protocol
        headers and inter protocol bindings are registered. JRegistry also
        maintains and assigns numerical protocol IDs. These are dynamically
        assigned IDs that have no relationship to IDs in PcapDLT or libpcap
        header files.</li>

        <li>JScanner - concrete class that performs the actual scan of the
        contents of the raw packet buffer. This class records this information
        in native structures which are then associated with JPacket and JHeader
        objects (peered with.)</li>

        <li>JProtocol - an enum table that lists all of the core protocols
        provided by jNetPcap API.</li>
        <li>JBinding - class that allows new inter protocol bindings to be
        registered or override any existing bindings already set, even on core
        protocols. You use this class to define how one protocol is bound to
        another. For example you can bind HTML protocol header on a different
        port, other than the defacto standard 80. As a matter of fact you can
        supply any kind of logic using this class which will determine the next
        protocol header that should follow the one that the binding was bound
        to.</li>
</ul>
<h3>Advanced: Scanner implementation details</h3>
It is time to discuss the JScanner class and how it works behind the
scenes. The scanner is actually implemented completely in native code.
It is a tight loop that scans the raw packet buffer (an array of raw
bytes or chars using C symantics) starting at the begining of the buffer
and assuming what the first header is, which is specified to it from
java space (can be automatically discovered using Pcap.datalink() method
or user supplied). The scanner uses numerical ids, assigned and
maintained by JRegistry, in the scanning and recoding process. As
headers are discovered information about those headers is recorded.
<p>The scanner implementation is almost completely in native code.
The scanner when its initialized allocates a large native memory block
to hold its state and state about every packet it decodes. A pointer
into the buffer is maintained which points to memory space where packet
state can be recorded. Pointer is advanced for each packet that is being
scanned. When the buffer is exhausted and the end is reached, the buffer
simply wraps around to the beginning and the buffer is reused. This is
the same algorithm that native libpcap uses for its capture buffer. So
both the raw packet buffer, maintained by libpcap, and the packet
decoded state information, maintained by JScanner, are kept in
temporary, roundrobin buffers. This is something that also applies to
other Pcap.loop and Pcap.dispatch methods that only dispatch raw byte
buffers.
<p>As packets arrive and the scanner is asked to scan them, it
increments a pointer to a packet_state_t structure, within its buffer.
The packet_state_t structure is where information is recorded about each
headers. First there is a compress bitmap which using header's numerical
IDs, records information about the presence of a header by setting a bit
in this bitmap (an unsigned integer). Calls to JPacket.hasHeader(int id)
simply check if a bit is set for a specific header ID and return true or
false. Therefore JPacket.hasHeader checks are very light and fast and
can be made frequently without having to worry about performance.
Secondly, the scanner also records header's position within the buffer
and the header's length. That information is also recorded in
packet_state_t which has a header_state_t array member. The last header
is typically a payload header, a special header that is catch all and
captures the remainder of the packet that was not matched with any
protocol header.</p>
<h3>Native JScanner structures</h3>
<p>Before we begin on native structures, lets look at the class
inheritance tree.
<pre>
jMemory
+-> JBuffer 
|   +-> JPacket - peered with libpcap packet data buffer
|
+-> JStruct
    +-> JPacket.State - peered with JScanners packet_state_t structure
    +-> JHeader.State - peered with JScanners header_state_t structure
</pre>
Further more, JPacket maintains an internal reference to a JPacket.State
object as a private field. That is JPacket is peered with libpcap packet
buffer, while a separate JPacket.State object is peered with the
JScanner packet state structure. Notice that JPacket extends JBuffer,
therefore any JPacket can be used as a normal JBuffer providing full
access to all of the packets raw contents. The state information is
allocated and maintained by JScanner.
</p>
<p>Packets are assigned a packet_state_t structure by peering a java
class with this native memory structure. jNetPcap uses the concept of
native peers by holding the physical memory address as a internal
private field within the java object. Native functions when called upon,
retrieve this address location, cast a local pointer to that physical
memory location for the structure that the class is peered with and then
access that information. So a JPacket.State object is peered with a
packet_state_t structure (residing in native memory) by simply changing
a single java field. Java objects that are peered, hold very little
additional information about the structure. There are some additional
fields that are maintained for security purposes such as the size of the
memory block and who the java owner of that memory block is. This
information is only maintained for security and deallocation of memory
purposes when the java parent object is garbage collected. This peering
mechanism allows previously allocated packets to be reused extrememly
efficiently, by simply changing a single pointer to a packet_state_t
structure within it and changing the state of the packet immediately.
JHeaders also maintain their state in this way.</p>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/jnetpcap/nio/package-summary.html"><B>PREV PACKAGE</B></A>&nbsp;
&nbsp;<A HREF="../../../org/jnetpcap/packet/annotate/package-summary.html"><B>NEXT PACKAGE</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/jnetpcap/packet/package-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
